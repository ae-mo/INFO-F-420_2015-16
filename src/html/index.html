<!DOCTYPE html>
<html lang="en">
	<head>
	  <title>Bootstrap Example</title>
	  <meta charset="utf-8">
	  <meta name="viewport" content="width=device-width, initial-scale=1">
	  <link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.6/lumen/bootstrap.min.css" rel="stylesheet" integrity="sha256-QSktus/KATft+5BD6tKvAwzSxP75hHX0SrIjYto471M= 
	sha512-787L1W8XyGQkqtvQigyUGnPxsRudYU2fEunzUP5c59Z3m4pKl1YaBGTcdhfxOfBvqTmJFmb6GDgm0iQRVWOvLQ==" crossorigin="anonymous">
	  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
	  <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
	</head>
	<body>

	<div class="jumbotron">
	  <h1>Bootstrap Tutorial</h1> 
	  <p>Bootstrap is the most popular HTML, CSS, and JS framework for developing responsive,
	  mobile-first projects on the web.</p> 
	</div>



	<div class="container-fluid">
	  <ul class="nav nav-pills nav-justified">
		<li class="active"><a data-toggle="pill" href="#home">Home</a></li>
		<li><a data-toggle="pill" href="#david">David</a></li>
		<li><a data-toggle="pill" href="#andrea">Andrea</a></li>
		<li><a data-toggle="pill" href="#game">Game</a></li>
		<li><a data-toggle="pill" href="#ack">Acknowledgements</a></li>
	  </ul>

	  <div class="tab-content">
	  <div id="home" class="tab-pane fade in active">
	  <div class="row-fluid">
		<nav class="col-sm-3" id="homeScrollSpy">
		<div class="row">&nbsp;</div>
		<div class="row">&nbsp;</div>
		  <ul class="nav nav-pills nav-stacked affix-top">
			<li class="active"><a href="#section1">Section 1</a></li>
			<li><a href="#section2">Section 2</a></li>
			<li><a href="#section3">Section 3</a></li>
			<li class="dropdown">
			  <a class="dropdown-toggle" data-toggle="dropdown" href="#">Section 4 <span class="caret"></span></a>
			  <ul class="dropdown-menu">
				<li><a href="#section41">Section 4-1</a></li>
				<li><a href="#section42">Section 4-2</a></li>                     
			  </ul>
			</li>
		  </ul>
		</nav>
		<div class="col-sm-9">
		  <div id="section1">    
			<h1>Section 1</h1>
			<p>Try to scroll this section and look at the navigation list while scrolling!</p>
		  </div>
		  <div id="section2"> 
			<h1>Section 2</h1>
			<p>Try to scroll this section and look at the navigation list while scrolling!</p>
		  </div>        
		  <div id="section3">         
			<h1>Section 3</h1>
			<p>Try to scroll this section and look at the navigation list while scrolling!</p>
		  </div>
		  <div id="section41">         
			<h1>Section 4-1</h1>
			<p>Try to scroll this section and look at the navigation list while scrolling!</p>
		  </div>      
		  <div id="section42">         
			<h1>Section 4-2</h1>
			<p>Try to scroll this section and look at the navigation list while scrolling!</p>
		  </div>
		</div>
	  </div>
	  </div>
	  <div id="david" class="tab-pane fade">
		<div class="row-fluid">
		<nav class="col-sm-3" id="myScrollspy">
		<div class="row">&nbsp;</div>
		<div class="row">&nbsp;</div>
		  <ul class="nav nav-pills nav-stacked">
			<li class="active"><a href="#d-routing" data-toggle="collapse" data-target="#d-drilldown-1">Routing</a>
				<div style="padding-left:0px;">
				  <ul id="d-drilldown-1" class="nav nav-pills nav-stacked collapse">
					<li><a href="#d-routing-simple">Routing in Simple Polygons</a></li>
					<li><a href="#d-routing-holes">Routing in Polygons with Holes</a></li>
					<li><a href="#d-routing-ortho">Routing in Simple Orthogonal Polygons</a></li>
				  </ul>
				  </div>
			</li>
			<li><a href="#d-coverage">Coverage</a></li>
			<li><a href="#d-impl">Algorithm Implementation</a></li>
		  </ul>
		</nav>
		<div class="col-sm-9">
		  <div id="d-routing">    
			<h1>Routing</h1>
			<div id="d-routing-simple">
				<h2>Routing in Simple Polygons</h2>
				<p>We first have a very important result we will use many times in the following theorems. 
				It is the simplest case, but, as in many cases in mathematics, it provides a strong 'block' to be able to build the next results easily. 
				The theorem has two parts, the second one being the most significant.</p>
			</div>
			<div>
				<h3>1. Given a simple polygon P, int(n/2) - 1 beacons are sometimes necessary to route between any pair of points in P.</h3>
				<h4>Proof</h4>
				<p>It is sufficient to provide an example of a simple polygon in which we would need int(n/2) - 1 beacons to route between 
				any pair of points in P, focusing on an extreme pair.</p>
				<p>In figure 1, we can see a simple polygon of 11 vertices. If we look at points G and F, to be able to take G to F’s position we will have 
				to place 4 beacons in the green vertices. This is caused by the fact that G will tend to get stuck in every spike during its journey to F,
				so we must place one beacon per spike, 4 in total ( int(11/2) – 1 = 5 – 1 = 4).</p>
			</div>
			<div>
				<h3>2. Given a simple polygon P, int(n/2) - 1 beacons are always sufficient to route between any pair of points in P.</h3>
				<h4>Proof</h4>
				<p>We will present an algorithm to place int(n/2) – 1 beacons in any simple polygon in such a way we can route between any pair of points in it.</p>
				<p>Firstly, we will triangulate the polygon. Considering this triangulation, we will peel off triangles starting with an extreme triangle 
				(lowest leaf of the dual graph associated to that triangulation) in each iteration. These removed triangles will mean “routed territory”, that 
				is to say, a part of the polygon in which we can route between any pair of points with the beacons already placed.</p>
				<p>There will be two types of extremes triangles a = ABC, as shown below:</p>
				<p>How are we going to place the beacons in our peeling off?</p>
				<p>In the case of figure 1, we will put a beacon Z in C. This way, any point in the three triangles can navigate to Z if attracted by it and vice versa. 
				We note it will be analogous if we had a hypothetic BDE instead of CDE.<br/>
				The second case is a bit more complicated, as we have to consider 4 triangles instead of 3. Here we will use something stronger than attraction, visibility, 
				which will be useful afterwards. Then we cannot put Z in C, as F may be to the left of line BC. But, considering the point B, we will be able to see triangles 
				ABC and BDF from it. Therefore we could put a beacon Z in B and we would have visibility over every triangle shown in the figure except DCE, but this will not 
				affect the future proof. All in all, every point before segment CD will be visible to Z and therefore every point could be routed to or from Z. (*)</p>
				<p>Now, how does the algorithm work?</p>
				<p>Recursively, we will choose an extreme triangle and we will place a beacon Z as described above. Then we will peel off some triangles depending on the case.
				Here we must define the base cases and the inductive step. </p>
				<ol>
					<li><p>If P is a single triangle or two triangles, we do nothing.<p></li>
					<li><p>If our chosen triangle is in case 1 (figure 3), we will place the beacon as seen above. This beacon will make possible routing between any pair of 
					points in the triangles. In this case, we peel off ABC (a1) and BCD (a2), getting a new simple polygon P’. We know we can route between any pair of points 
					contained in the peeled part and also contained in P’ by induction hypothesis. So we just need to check if we can navigate from a point t in (a1 u a2) to a 
					point s in P', therefore P would be “beaconizable”. But we can do this easily by first routing from t to Z and then from Z to s by induction hypothesis.<p></li>
					<li><p>If our chosen triangle is in case 2 (figure 4), we will place the beacon as seen above. Now we peel off ABC (a1) and BDF (a4), getting a simple P’.
					Now our separation lines will be BC and BD. We know we can navigate without problems within triangles a1 and a4 separately, and within P’ by induction. 
					What happens in this case if we want to route between a point t in the peeled part and a point s in P’? We can route from t to Z and then from Z to s by 
					induction hypothesis, with s being situated either in a1 or a4. The last case to consider would be having t and s in a1 and a4 respectively, and we could 
					obviously route from one to another just using Z.<p></li>
				</ol>
				<p>So using this algorithm we see that we remove two triangles each time we place a new beacon. As the number of triangles in the triangulation is n – 2, 
				with n being the number of vertices, the total number of beacons placed will be at most int( (n – 2) / 2 ), which is the same as int(n/2) – 1.</p>
			</div>
			<div id="d-routing-holes">
				<h2>Routing in Polygons with Holes</h2>
				<p>Now we will take a look at polygons with n vertices and h holes.</p>
					<div>
						<h3>3. Given a polygon P with n vertices and h holes, int( n/2 ) - h - 1 beacons are sometimes necessary to route between a pair of points in P.</h3>
						<h4>Proof</h4>
						<p>We already know this is clear for h = 0. Now, how can we build an example with holes fulfilling this bound? We could use the valid example of figure 0 and 
						try to adapt it with holes. The important concept in that examples were the spikes, so couldn’t we add more spikes thanks to the holes? We could build holes like 
						in figure 5, seen in green:</p>
						<p>Then we would need many beacons to get a point s out of the deepest spike of the polygon, 4 in this concrete case. So we will use this idea combined with a polygon
						of this very form itself as in figure 0, with 1 hole as seen in figure 6:</p>
						<p>In this example, we can see that we have 1 hole, the main polygon has 11 vertices and the hole part has 12 vertices (11 plus 1 to close it). 
						Thus we have 23 vertices. <br/>			
						In order to take the red point to what in figure 0 was F, we must first leave the spikes of the hole an then the main spikes. We will need 4 beacons to dodge the main
						spikes as seen in figure 0, plus 4 for the hole spikes (same reasoning). But we have to add another one, B in figure 6, to be able to finally leave the hole when the
						first of the main spike beacons gets activated. So we will need 9 beacons in total and we have that int(23/2)- 1 -1 = 11 - 2 = 9. <br/>
						We have presented a successful example with 1 hole, and we could repeat this method recursively to generalize this situation to h holes.
						</p>
					</div>
					<div>
						<h3>4. Given a polygon P with n vertices and h holes, int( n/2 ) + h - 1 beacons are always sufficient to route between a pair of points in P.</h3>
						<h4>Proof</h4>
						<p>As in the theorem for simple polygons, we first triangulate the polygon and consider the dual graph of the triangulation.  This dual graph, as P is not 
						simple, may have cycles, as seen in figure 7:</p>
						<p>When we do this we get a connected graph without cycles, and we have to do it h times, adding 2*h vertices and getting a simple polygon of 2*h + n vertices.
						Now we can use the result of theorem 2, because the position of the new vertices does not affect routing in any way (as they are as close as we want to the old 
						vertices). Thus we have that it can be routed with int( (2*h + n)/2) – 1 = int(n/2) + h – 1 beacons.</p>
					</div>
			</div>
			<div id="d-routing-ortho">
				<h2>Routing in Simple Orthogonal Polygons</h2>
				<p>Here we will just present a better bound to the necessary number of beacons to route between two points in a simple orthogonal polygon. We note that theorems 1 
				and 2 are applicable to this kind of polygons.</p>
				<h3>4. Given a polygon P with n vertices and h holes, int( n/2 ) + h - 1 beacons are always sufficient to route between a pair of points in P.</h3>
				<h4>Proof</h4>
				<p>As always, we will give an example to prove that there exists a polygon with those characteristics fulfilling the statement. <br/>
				In this case, we have a very simple, orthogonal polygon with 12 vertices and needing just int(12/4) – 1 = 3 – 1 = 2 beacons to route, looking at two extreme points
				C and K:
				</p>
				<p><strong><i>(*) Mistake found in the article Combinatorics of Beacon-Based Routing and Coverage </i></strong></p>
				<p>In this article, which is the fundamental basis of this section, the algorithm depicted to build the proof for theorem 2 has a flaw. <br/>
				In the case 2 of these algorithm, the beacon Z is placed somewhere in the segment CD, in order to be able to peel off three triangles instead of two, 
				because “there always exists a point in the segment CD from which we will be able to see the entire pentagon ACDFB”. But this is not true as the next figure shows:
				</p>
				<p>This flaw does not seem to be easily solved if we want to peel off these three triangles, but it certainly could be avoided by just peeling two triangles as we did 
				in our proof in this section, which does not affect the result of the theorem. 
				</p>
			</div>
		  </div>
		  <div id="d-coverage"> 
			<h1>Coverage</h1>
			<p>What does coverage of a polygon mean? A polygon is covered by a set of beacons if every point of the polygon is attracted by at least one of the beacons. <br/>
			We note that this is a different condition to routing, although these two concepts are related. Routing is a strongest condition, so every routed polygon is also 
			covered, but we do not have the opposite implication. Therefore, we will need fewer points to cover, generally, than when we routed.
			</p>
			<p>We will remember two important simple concepts that will be very useful in this section. The attraction region and the inverse attraction region. 
			The attraction region of a point A is the set of points in P that are attracted by A (they are able to reach A when this point is activated as a beacon). 
			Inversely, the inverse attraction region of a point B is the set of points in P that can attract B when they are activated as beacons. 
			</p>
			<p>Now we can define the coverage saying that a polygon P is covered by a set of beacons if and only if P is contained in the union of the attraction regions of the beacons in the set.</p>
		  </div>        
		  <div id="d-impl">         
			<h1>Section 3</h1>
			<p>Try to scroll this section and look at the navigation list while scrolling!</p>
		  </div>
		</div>
	  </div>
	  </div>
	</div>
	</div>

	</body>
</html>