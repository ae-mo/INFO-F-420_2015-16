<!DOCTYPE html>
<html lang="en">
	<head>
	  <title>Project</title>
	  <meta charset="utf-8">
	  <meta name="viewport" content="width=device-width, initial-scale=1">
	  <link rel="stylesheet" href="http://elyxer.nongnu.org/lyx.css" type="text/css" media="all"/>
	  <link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.6/lumen/bootstrap.min.css" rel="stylesheet" integrity="sha256-QSktus/KATft+5BD6tKvAwzSxP75hHX0SrIjYto471M= 
	sha512-787L1W8XyGQkqtvQigyUGnPxsRudYU2fEunzUP5c59Z3m4pKl1YaBGTcdhfxOfBvqTmJFmb6GDgm0iQRVWOvLQ==" crossorigin="anonymous">
	  <link rel="stylesheet" type="text/css" href="css/style.css">
	  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
	  <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
	  <script type="text/javascript" async
  		src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
		</script>
	  <script type="text/javascript">
	  	$( document ).ready(function() {

	  		$('#menu').width($( window ).width()/5);
	  		$('#menu.affix').width($( window ).width()/5);
	  	});

	  	$(window).resize(function() {
        $('#menu').width($( window ).width()/5);
	  		$('#menu.affix').width($( window ).width()/5);
    });
	  </script>
	  <script type="text/javascript">
	  	$( document ).ready(function() {

	  		$('#menu1').width($( window ).width()/5);
	  		$('#menu1.affix').width($( window ).width()/5);
	  	});

	  	$(window).resize(function() {
        $('#menu1').width($( window ).width()/5);
	  		$('#menu1.affix').width($( window ).width()/5);
    });
	  </script>
	</head>
	<body data-spy="scroll" data-target="#myScrollspy" >
		<div class="jumbotron">
		  <h1>Beacon Based Routing and Coverage</h1> 
		  <p>Université Libre de Bruxelles</p>
		  <p>A. A. 2015/2016</p>
		  <p>Course: INFO-F-420 Computational Geometry</p>
		  <p>Presented to Professor Stefan Langerman</p>
		  <p>by David Alvarez Bobillo and Andrea Morciano</p>
		</div>
		<div class="container-fluid">
			<ul class="nav nav-pills nav-justified">
				<li class="active"><a data-toggle="pill" href="#home">Home</a></li>
				<li><a data-toggle="pill" href="#david">David</a></li>
				<li><a data-toggle="pill" href="#andrea">Andrea</a></li>
				<li><a data-toggle="pill" href="#game">Game</a></li>
				<li><a data-toggle="pill" href="#ack">Acknowledgements</a></li>
			</ul>
			<div class="tab-content">
				<div id="home" class="container-fluid tab-pane fade in active">
					<div class="row">
						<div class="col-md-1"></div>
						<div class="col-md-10">
							<h1>Introduction</h1>
							<p>
								The aim of this project is to present the concept of <i>Beacon based Routing</i>, which is a way of traveling inside a polygon using structures called beacons. But what is this?
							</p>
							<p>
								A beacon is a fixed point contained in a polygon which can induce a linear attraction to any other point in the polygon, similar to a gravitational or magnetic attraction. So a beacon can be activated, i.e. it starts producing this attraction, or deactivated, losing this capacity. And how would a normal point behave when attracted by a beacon’s pull? It will move linearly towards the beacon. If it gets blocked by an edge of the polygon, then it will move across the edge in the direction which minimizes the distance between the point and the beacon. When a point p is able to reach a beacon b without getting stuck in the process, we say that b attracts p. Due to edges’ intrusion, our point may not be able to eventually reach the beacon, getting stuck in some other point called dead point. Why can this happen? Our point may be not able to decide what path to take when it reaches an edge if the distance to the beacon does not decreases in any direction, as seen in the next figure, where the red point tries to reach the yellow beacon:
							</p>
							<div>
								<figure>
									<img class="img-responsive" src="img/intro/0.png">
								</figure>
								<div class="row">&nbsp;</div>
							</div>
							<p>
								Or it may take a direction along the edge which “seems” more promising but at the end it makes you get stuck in a different part of the polygon, as seen here:
							</p>
							<div>
								<figure>
									<img class="img-responsive" src="img/intro/1.png">
								</figure>
								<div class="row">&nbsp;</div>
							</div>
							<p>
								How is routing done using beacons then? We will say that a point A can be routed to another point B if there is a sequence of beacons that can be activated in a determinate order and one at a time such that A is able to reach B by travelling through the beacons. The point B will have to be activated in the end so that A eventually reaches B but it will not be considered as a beacon itself when counting the sequence. In addition, each beacon could be activated only once. 
							</p>
							<p>
								Another important concept related to beacons is <i>coverage</i>. A polygon will be covered by a set of beacons if any point of the polygon is attracted by at least one beacon in the chosen set.
							</p>

						</div>
						<div class="col-md-1"></div>
						<div class="row">&nbsp;</div>
						<div class="row">&nbsp;</div>
					</div>
				</div>
				<div id="david" class="container-fluid tab-pane fade">
					<div class="row">&nbsp;</div>
					<div class="row">&nbsp;</div>
					<div class="row">
						<div  id="col" class="col-sm-3">
							<nav id="myScrollspy">
							  <ul id="menu" class="nav nav-pills nav-stacked well" data-spy="affix" data-offset-top="360">
								<li class="active"><a href="#d-routing">Routing</a>
									<div style="padding-left:0px;" class="">
									  <ul id="d-drilldown" class="nav nav-pills nav-stacked">
										<li><a href="#d-routing-simple">Simple Polygons</a></li>
										<li><a href="#d-routing-holes">Polygons with Holes</a></li>
										<li><a href="#d-routing-ortho">Simple Orthogonal Polygons</a></li>
									  </ul>
									 </div>
								</li>
								<li><a href="#d-coverage">Coverage</a>
									<div style="padding-left:0px;">
									  <ul id="d-drilldown" class="nav nav-pills nav-stacked submenu">
										<li><a href="#d-necessary">'Sometimes Necessary' Bound</a></li>
										<li><a href="#d-sufficient">'Always sufficient' bound</a></li>
										<li><a href="#d-coverage-ortho">Coverage in Orthogonal Polygons</a></li>
									  </ul>
									</div>
								</li>
								<li><a href="#d-impl">Algorithm Implementation</a>
									<div style="padding-left:0px;">
									  <ul id="d-drilldown" class="nav nav-pills nav-stacked submenu">
										<li><a href="#d-sufficient-beacons">Sufficient Beacons</a></li>
										<li><a href="#d-beacons-to-route">Beacons to Route</a></li>
									  </ul>
									</div>
								</li>
								<li><a href="#d-applet">Applet</a></li>
								<li><a href="#d-biblio">Bibliography</a></li>
							  </ul>
							</nav>
						</div>
						<div class="col-sm-9">
						  <div id="d-routing">    
							<h1>Routing</h1>
							<div id="d-routing-simple">
								<h2>Routing in Simple Polygons</h2>
								<p>We first have a very important result we will use many times in the following theorems. 
								It is the simplest case, but, as in many cases in mathematics, it provides a strong 'block' to be able to build the next results easily. 
								The theorem has two parts, the second one being the most significant.</p>
							</div>
							<div>
								<h3>1. Given a simple polygon P, \(\left\lfloor \frac{n}{2}\right\rfloor -1\) beacons are sometimes necessary to route between any pair of points in P.</h3>
								<h4>Proof</h4>
								<p>It is sufficient to provide an example of a simple polygon in which we would need \(\left\lfloor \frac{n}{2}\right\rfloor -1\) beacons to route between 
								any pair of points in P, focusing on an extreme pair.</p>
								<div>
									<figure>
										<img class="img-responsive" src="img/david/0.png">
										<figcaption class="text-center"><i>Figure 0.</i></figcaption>
									</figure>
									<div class="row">&nbsp;</div>
								</div>
								<p>In figure 1, we can see a simple polygon of 11 vertices. If we look at points G and F, to be able to take G to F’s position we will have 
								to place 4 beacons in the green vertices. This is caused by the fact that G will tend to get stuck in every spike during its journey to F,
								so we must place one beacon per spike, 4 in total (\(\left\lfloor \frac{11}{2}\right\rfloor -1=5-1=4\)).</p>
							</div>
							<div>
								<h3>2. Given a simple polygon P, \(\left\lfloor \frac{n}{2}\right\rfloor -1\) beacons are always sufficient to route between any pair of points in P.</h3>
								<h4>Proof</h4>
								<p>We will present an algorithm to place \(\left\lfloor \frac{n}{2}\right\rfloor -1\) beacons in any simple polygon in such a way we can route between any pair of points in it.</p>
								<p>Firstly, we will triangulate the polygon. Considering this triangulation, we will peel off triangles starting with an extreme triangle 
								(lowest leaf of the dual graph associated to that triangulation) in each iteration. These removed triangles will mean “routed territory”, that 
								is to say, a part of the polygon in which we can route between any pair of points with the beacons already placed.</p>
								<p>There will be two types of extremes triangles a = ABC, as shown below:</p>
								<div>
									<figure>
										<img class="img-responsive" src="img/david/1.png">
										<figcaption class="text-center"><i>Figure 1: ABC is a single leaf, as BCD has no more children. The rest of P is located via CDE.</i></figcaption>
									</figure>
									<div class="row">&nbsp;</div>
								</div>
								<div>
									<figure>
										<img class="img-responsive" src="img/david/2.png">
										<figcaption class="text-center"><i>Figure 2: BCD has two children, ABC and BDF. The rest of P is located via CDE as before.</i></figcaption>
									</figure>
									<div class="row">&nbsp;</div>
								</div>
								<p>How are we going to place the beacons in our peeling off?</p>
								<p>In the case of figure 1, we will put a beacon Z in C. This way, any point in the three triangles can navigate to Z if attracted by it and vice versa. 
								We note it will be analogous if we had a hypothetic BDE instead of CDE.<br/>
								The second case is a bit more complicated, as we have to consider 4 triangles instead of 3. Here we will use something stronger than attraction, visibility, 
								which will be useful afterwards. Then we cannot put Z in C, as F may be to the left of line BC. But, considering the point B, we will be able to see triangles 
								ABC and BDF from it. Therefore we could put a beacon Z in B and we would have visibility over every triangle shown in the figure except DCE, but this will not 
								affect the future proof. All in all, every point before segment CD will be visible to Z and therefore every point could be routed to or from Z. (*)</p>
								<p>Now, how does the algorithm work?</p>
								<p>Recursively, we will choose an extreme triangle and we will place a beacon Z as described above. Then we will peel off some triangles depending on the case.
								Here we must define the base cases and the inductive step. </p>
								<ol>
									<li><p>If P is a single triangle or two triangles, we do nothing.<p></li>
									<li><p>If our chosen triangle is in case 1 (figure 3), we will place the beacon as seen above. This beacon will make possible routing between any pair of 
									points in the triangles. In this case, we peel off ABC (a1) and BCD (a2), getting a new simple polygon P’. We know we can route between any pair of points 
									contained in the peeled part and also contained in P’ by induction hypothesis. So we just need to check if we can navigate from a point t in (a1 u a2) to a 
									point s in P', therefore P would be “beaconizable”. But we can do this easily by first routing from t to Z and then from Z to s by induction hypothesis.<p>
										<div>
											<figure>
												<img class="img-responsive" src="img/david/3.png">
												<figcaption class="text-center"><i>Figure 3.</i></figcaption>
											</figure>
											<div class="row">&nbsp;</div>
										</div>
									</li>
									<li><p>If our chosen triangle is in case 2 (figure 4), we will place the beacon as seen above. Now we peel off ABC (a1) and BDF (a4), getting a simple P’.
									Now our separation lines will be BC and BD. We know we can navigate without problems within triangles a1 and a4 separately, and within P’ by induction. 
									What happens in this case if we want to route between a point t in the peeled part and a point s in P’? We can route from t to Z and then from Z to s by 
									induction hypothesis, with s being situated either in a1 or a4. The last case to consider would be having t and s in a1 and a4 respectively, and we could 
									obviously route from one to another just using Z.<p>
										<div>
											<figure>
												<img class="img-responsive" src="img/david/4.png">
												<figcaption class="text-center"><i>Figure 4.</i></figcaption>
											</figure>
											<div class="row">&nbsp;</div>
										</div>
									</li>
								</ol>
								<p>So using this algorithm we see that we remove two triangles each time we place a new beacon. As the number of triangles in the triangulation is n – 2, 
								with n being the number of vertices, the total number of beacons placed will be at most \(\left\lfloor \frac{n-2}{2}\right\rfloor\), which is the same as \(\left\lfloor \frac{n}{2}\right\rfloor -1\).</p>
							</div>
							<div id="d-routing-holes">
								<h2>Routing in Polygons with Holes</h2>
								<p>Now we will take a look at polygons with n vertices and h holes.</p>
									<div>
										<h3>3. Given a polygon P with n vertices and h holes, \(\left\lfloor \frac{n}{2}\right\rfloor -h-1\) beacons are sometimes necessary to route between a pair of points in P.</h3>
										<h4>Proof</h4>
										<p>We already know this is clear for \(h=0\). Now, how can we build an example with holes fulfilling this bound? We could use the valid example of figure 0 and 
										try to adapt it with holes. The important concept in that examples were the spikes, so couldn’t we add more spikes thanks to the holes? We could build holes like 
										in figure 5, seen in green:</p>
										<div>
											<figure>
												<img class="img-responsive" src="img/david/5.png">
												<figcaption class="text-center"><i>Figure 5.</i></figcaption>
											</figure>
											<div class="row">&nbsp;</div>
										</div>
										<p>Then we would need many beacons to get a point s out of the deepest spike of the polygon, 4 in this concrete case. So we will use this idea combined with a polygon
										of this very form itself as in figure 0, with 1 hole as seen in figure 6:</p>
										<div>
											<figure>
												<img class="img-responsive" src="img/david/6.png">
												<figcaption class="text-center"><i>Figure 6.</i></figcaption>
											</figure>
											<div class="row">&nbsp;</div>
										</div>
										<p>In this example, we can see that we have 1 hole, the main polygon has 11 vertices and the hole part has 12 vertices (11 plus 1 to close it). 
										Thus we have 23 vertices. <br/>			
										In order to take the red point to what in figure 0 was \(F\), we must first leave the spikes of the hole an then the main spikes. We will need 4 beacons to dodge the main
										spikes as seen in figure 0, plus 4 for the hole spikes (same reasoning). But we have to add another one, \(B\) in figure 6, to be able to finally leave the hole when the
										first of the main spike beacons gets activated. So we will need 9 beacons in total and we have that \(\left\lfloor \frac{23}{2}\right\rfloor -1-1=11-2=9\). <br/>
										We have presented a successful example with 1 hole, and we could repeat this method recursively to generalize this situation to \(h\) holes.
										</p>
									</div>
									<div>
										<h3>4. Given a polygon \(P\) with n vertices and \(h\) holes, \(\left\lfloor \frac{n}{2}\right\rfloor +h-1\) beacons are always sufficient to route between a pair of points in \(P\).</h3>
										<h4>Proof</h4>
										<p>As in the theorem for simple polygons, we first triangulate the polygon and consider the dual graph of the triangulation.  This dual graph, as \(P\) is not 
										simple, may have cycles, as seen in figure 7:</p>
										<div>
											<figure>
												<img class="img-responsive" src="img/david/7.png">
												<figcaption class="text-center"><i>Figure 7.</i></figcaption>
											</figure>
											<div class="row">&nbsp;</div>
										</div>
										<p>What we will do know is to get rid of these cycles by removing an edge of each cycle: we add two vertices very close to those of the edge, hence creating a very thin artificial channel in order to remove the hole (figure 8).</p>
										<div>
											<figure>
												<img class="img-responsive" src="img/david/8.png">
												<figcaption class="text-center"><i>Figure 8.</i></figcaption>
											</figure>
											<div class="row">&nbsp;</div>
										</div>
										<p>When we do this we get a connected graph without cycles, and we have to do it h times, adding \(2h\) vertices and getting a simple polygon of \(2h+n\) vertices.
										Now we can use the result of theorem 2, because the position of the new vertices does not affect routing in any way (as they are as close as we want to the old 
										vertices). Thus we have that it can be routed with \(\left\lfloor \frac{2h+n}{2}\right\rfloor -1=\left\lfloor \frac{n}{2}\right\rfloor +h-1\) beacons.</p>
									</div>
							</div>
							<div id="d-routing-ortho">
								<h2>Routing in Simple Orthogonal Polygons</h2>
								<p>Here we will just present a better bound to the necessary number of beacons to route between two points in a simple orthogonal polygon. We note that theorems 1 
								and 2 are applicable to this kind of polygons.</p>
								<h3>4. Given a polygon P with n vertices and h holes, int( n/2 ) + h - 1 beacons are always sufficient to route between a pair of points in P.</h3>
								<h4>Proof</h4>
								<p>As always, we will give an example to prove that there exists a polygon with those characteristics fulfilling the statement. <br/>
								In this case, we have a very simple, orthogonal polygon with 12 vertices and needing just int(12/4) – 1 = 3 – 1 = 2 beacons to route, looking at two extreme points
								C and K:
								</p>
								<div>
									<figure>
										<img class="img-responsive" src="img/david/9.png">
										<figcaption class="text-center"><i>Figure 9.</i></figcaption>
									</figure>
									<div class="row">&nbsp;</div>
								</div>
								<p><strong><i>(*) Mistake found in the article Combinatorics of Beacon-Based Routing and Coverage </i></strong></p>
								<p>In this article, which is the fundamental basis of this section, the algorithm depicted to build the proof for theorem 2 has a flaw. <br/>
								In the case 2 of these algorithm, the beacon Z is placed somewhere in the segment CD, in order to be able to peel off three triangles instead of two, 
								because “there always exists a point in the segment CD from which we will be able to see the entire pentagon ACDFB”. But this is not true as the next figure shows:
								</p>
								<div>
									<figure>
										<img class="img-responsive" src="img/david/10.png">
									</figure>
									<div class="row">&nbsp;</div>
								</div>
								<p>This flaw does not seem to be easily solved if we want to peel off these three triangles, but it certainly could be avoided by just peeling two triangles as we did 
								in our proof in this section, which does not affect the result of the theorem. 
								</p>
							</div>
						  </div>
						  <div id="d-coverage"> 
							<h1>Coverage</h1>
							<p>What does coverage of a polygon mean? A polygon is covered by a set of beacons if every point of the polygon is attracted by at least one of the beacons. <br/>
							We note that this is a different condition to routing, although these two concepts are related. Routing is a strongest condition, so every routed polygon is also 
							covered, but we do not have the opposite implication. Therefore, we will need fewer points to cover, generally, than when we routed.
							</p>
							<p>We will remember two important simple concepts that will be very useful in this section. The attraction region and the inverse attraction region. 
							The attraction region of a point A is the set of points in P that are attracted by A (they are able to reach A when this point is activated as a beacon). 
							Inversely, the inverse attraction region of a point B is the set of points in P that can attract B when they are activated as beacons. 
							</p>
							<p>Now we can define the coverage saying that a polygon P is covered by a set of beacons if and only if P is contained in the union of the attraction regions of the beacons in the set.</p>
							<div id="d-necessary">
								<h2>‘Sometimes Necessary’ Bound</h2>
								<p>First, we will focus on giving a lower bound on the number of beacons sometimes necessary to cover arbitrarily large polygons.
								</p>
								<div>
									<h3>3. Given a simple polygon P with n vertices, we may need arbitrarily close to int( 4n/13 ) beacons to cover P.</h3>
									<h4>Proof</h4>
									<p>In order to prove this, we will present a specifically designed example on which we will have to use “many” beacons to cover. Again, as we did in routing too, the concept of spike will be proved very useful and we will use it intensively, as spikes prevent the points to reach the activated beacons due to the longer path they have to travel.</p>
									<div>
										<figure>
											<img class="img-responsive" src="img/david/11.png">
											<figcaption class="text-center"><i>Figure 10.</i></figcaption>
										</figure>
										<div class="row">&nbsp;</div>
									</div>
									<p>In figure 10 we can see that the inverse attraction regions of the vertex in red (shadowed) are disjoint, so we will at least 3 beacons to cover it (one in each zone). We will need 3 beacons for a polygon of 9 vertices.</p>
									<p>Now we will try to extend this example to make a family of polygons with n vertices.</p>
									<p>Due to the angles of the spikes, it is not easy to replicate more spikes and extend the polygon in a suitable way to n. What we will do is to combine the spikes recursively to form a fractal polygon complex enough to give us the desired bound. </p>
									<p>We will now define the concepts of “angled –in” polygon and “angled-out” polygon. An angled-in spike polygon would have the “main” shape of Figure 10, and want we will do is to combine two of these polygons to create an angled out polygon as depicted in the figure 11:</p>
									<div>
										<figure>
											<img class="img-responsive" src="img/david/12.png">
											<figcaption class="text-center"><i>Figure 11.</i></figcaption>
										</figure>
										<div class="row">&nbsp;</div>
									</div>
									<p>We can see that we have removed one spike of each angled-in polygon in order to “glue” them, forming an angled-out polygon. How do continue with the recursion? It is very important to note that the blue shaded part of the above polygon will be a spike of another angled-in polygon, therefore completing the recursion, as seen in figure 12:</p>
									<div>
										<figure>
											<img class="img-responsive" src="img/david/13.png">
											<figcaption class="text-center"><i>Figure 12.</i></figcaption>
										</figure>
										<div class="row">&nbsp;</div>
									</div>
									<p>So we build our family of polygons like this. In the next iteration, we would remove the white spike of figure 12 and with two copies of the angled-in polygon we would create another angled-out polygon, and so on.</p>
									<p>Now we have to count the vertices and the independent points we have in the family. What is an independent point? The red points seen in the figures which make us put beacons next to them.</p>
									<p>If we start with an angled-in polygon with n vertices and we follow the process seen above to create another bigger angled-in polygon, how many vertices will this new polygon have? We will start with a polygon with one more vertex in order to simplify the counting:</p>
									<div>
										<figure>
											<img class="img-responsive" src="img/david/14.png">
											<figcaption class="text-center"><i>Figure 13.</i></figcaption>
										</figure>
										<div class="row">&nbsp;</div>
									</div>
									<p>First we remove one spike, n-2. Then we double the vertices with two copies and merge one edge eliminating two vertex, but we add two to create the angled-out spike as in figure 11, 2n-6+2 = 2n-4. Then we double the vertices again, 4n-8, finally we add four vertices to create the final spike, 4n-4.</p>
									<p>What is the number of independent points? If we start with b independent points in an angled-in polygon, first we delete one when removing one spike, then we make two copies, 2b-2. For each two copies, we have an angled-out spike which will give us another independent point, 2b-1. Then, in the final step creating the bigger angled-in polygon, we double the independent points and we finally add another one due to the las spike we add, so in total 4b-1.</p>
									<p>Using this information, we know define T(k) as the number of vertices in the family of polygons after k iterations. For example, T(0) would be 10 as seen in figure 13. Now we know that we have:	<br/>
									T(k)=4T(k-1)-4<br/>

									By easily solving this recursion we have:<br/>

									T(k)=  1/3  ( 26∙ 4^k+4 )<br/>

									Similarly, we know define I(k) as the number of independent points in the family of polygons after k iterations. For example, I(0) would be 3 as seen in figure 13. Now we know that we have:	<br/>
									I(k)=4I(k-1)-1<br/>

									By easily solving this recursion we have:<br/>

									I(k)=  1/3  ( 8∙ 4^k+1 )</p>
									<p>Here we are finally in a good position to end our proof and give a family of polygons with n vertices that will need asymptotically int( 4n/13 ) beacons to cover. This is caused because we have: <br/>

									lim┬(k→∞)⁡〖(1/3  ( 8∙ 4^k+1 ))/(1/3  ( 26∙ 4^k+4 ))〗=  4/13</p>
									<p>So we will just consider our family of polygons and we have the result.</p>
								</div>

							</div>
							<div id="d-sufficient">
								<h2>‘Always Sufficient’ Bound</h2>
								<p>We now take a look at the number of beacons that will be sufficient to cover a polygon P with n vertices and h holes in any case.<br/>
								As seen at the beginning of this section, due to the relation existing between routing and coverage, the bound found here should be lower than that we reached in routing, which was int( n/2 ) + h – 1. 
								</p>
								<div>
									<h3>4. Given a polygon P with n vertices and h holes, int( (n+h)/3 ) beacons are always sufficient to cover P.</h3>
									<h4>Proof</h4>
									<p>This proof, contrarily to the last one we saw, is far simpler and it is based in the art gallery problem. The art gallery problem indeed solves our problem, since art gallery’s is included in ours, because every guarding of a polygon is also a coverage of the polygon (every point is seen by a guard, so every point would be attracted to this guard without any problem).</p>
									<p>The standard solution of the art gallery problem tell us that we can guard a polygon with n vertices and h holes with int( (n+h)/3 ) guards. So we can cover the polygon with int( (n+h)/3 ) beacons.</p>
								</div>
							</div>
							<div id="d-coverage-ortho">
								<h2>Coverage in Orthogonql Polygons</h2>
								<p>Orthogonal polygons are a special kind of polygons, and we can use these special characteristics to get better bounds on coverage. </p>
								<p>For example, we know that in the case of orthogonal polygons, the art gallery problem gives us a better bound than int( (n+h)/3 ), int( (n+h)/4  ). So we have that int( (n+h)/4  ) beacons are always sufficient to cover a polygon P with these characteristics. </p>
								<p>For the sometimes necessary beacons to cover an orthogonal polygon, we can use the same example we used in “Routing in Orthogonal Polygons”:</p>
								<div>
										<figure>
											<img class="img-responsive" src="img/david/15.png">
											<figcaption class="text-center"><i>Figure 14.</i></figcaption>
										</figure>
										<div class="row">&nbsp;</div>
									</div>
								<p>The orthogonal polygon, P, has 12 vertices and just needs 2 beacons to cover, as seen in figure 14. P is divided into parts A and B by the brown line. The first beacon in green attracts every point in part A in the polygon, as the second attracts very point in part B.</p>
								<p>This family can be extended (adding 4 vertices each time) and we will have a ‘serpent’ family of orthogonal polygons which require int( (n+4)/8 ) beacons to cover.</p>
							</div>
						  </div>        
						  <div id="d-impl">         
							<h1>Implementation of the Algorithm</h1>
							<div id="d-sufficient-beacons">
								<h2>Sufficient Beacons</h2>
								<p>How is the algorithm of Theorem 2 really implemented? It is written in Javascript and using the P5 library. We will use a DCEL in order to keep track of the polygons.</p>
								<p>First, we will introduce the simple polygon in clock-wise order and we will press enter. We will keep the vertices in order in a global array. When the polygon has been introduced in its entirety, we initialize the DCEL, setting an inner face and an outer face. </p>
								<p>After this, we triangulate the polygon. We have implemented the triangulation using the ear clipping method, i.e. first finding an ear (by traveling through the vertices except the last one because of the Two Ears Problem) and then removing it recursively. During the algorithm, we update the DCEL accordingly.</p>
								<p>When we have finished the triangulation, we now can start with the algorithm of theorem 2, but first we make a copy of the DCEL in order not to lose its information when modifying its structure during the upcoming algorithm. We will manage to do everything just using the DCEL.</p>
								<p>We have two base cases and then the main step. Base case 1 consist in having just a triangle (2 faces) and we put the beacon in the first vertex. Base case 2 consist in having 2 triangles (3 faces) and we choose to put the beacon in the middle edge, because of the visibility. We are able to do this because we use a function which tell us the number of edges of a given vertex.</p>
								<p>Eventually, we have the heart of the algorithm in the main case. We travel the vertices in order to find what will be a leaf in the dual graph, i.e. a vertex with only two edges. When we are there, we identify the vertex’ opposite edge in the triangle. Now we will distinguish between four cases. If we are in one of these cases it will mean that this triangle is effectively a lowest leaf. Testing this is done in constant time, so the algorithm will not slow down excessively. </p>
								<p>The first one corresponds to case 1 in the theorem with what will be P’ to the left. We know if we are in this situation by examining the face of the suitable (half)edge and checking in it “faces” the outer face:</p>
								<div>
									<figure>
										<img class="img-responsive" src="img/david/16.png">
									</figure>
									<div class="row">&nbsp;</div>
								</div>
								<p>If we have this situation, then we know it is a lowest leaf. Then we check if the point where the beacon will be placed has already another previous beacon, if not, we save the new beacon in a global array of beacons. Finally, we delete first the triangle of the vertex and then the triangle containing the edge we check by using a function that deletes “leaf” triangles from the DCEL and we call the algorithm function recursively with this new DCEL. </p>
								<p>The second case is analogous to the first one but with P’ to the right.</p>
								<p>The third one corresponds to case 2 in the theorem with what will be P’ to the left. In order to check this we will look at two suitable edges as depicted in the next figure:</p>
								<div>
									<figure>
										<img class="img-responsive" src="img/david/17.png">
									</figure>
									<div class="row">&nbsp;</div>
								</div>
								<p>If both (half)edges “face” the outer face, we know that we are in this situation, and it will be a lowest leaf. We put the beacon in its place after checking repetition and then we remove the two adequate triangles from the DCEL (the vertex triangle and the triangle containing the edges we checked). As done before, we call the algorithm function recursively with the new DCEL.</p>
								<p>The fourth case is again analogous to the third one but with P’ to the right.</p>
								<p>If we are not in any of these cases, we then know the vertex’ triangle is not a lowest leaf, so we do nothing and just continue the search. We know for sure we will eventually find a lowest leaf.</p>
							</div>
							<div id="d-beacons-to-route">
								<h2>Beacons to Route</h2>
								<p>At the same time we perform the calculations to obtain the sufficient beacons from theorem 2, we will also try to select, given two points inside the polygon, an ordered subset of beacons that we could use to route between then. This subset will be contained in the set of beacons from theorem 2.</p>
								<p>Firstly, we will get the faces (triangles) both points are located in. Then we will perform some actions, guided by the previous algorithm. We will start and continue with the algorithm until we peel off a triangle that contains one of the points. Then that will mean we have started our path in this direction. We will keep two lists with beacons, with the beacons we have already visited in each direction, as each list of beacons is moving towards the other until they finally meet. <br/>
								So how do we update the lists? The first beacons of the two lists are those two related to the peeling off of the faces containing the first and the second point, respectively. When we have to peel off two new triangles, we check if any of them is “influenced” by the beacons of a list, more precisely, the last beacon of the list as it is the one which leads the way. What means “influenced”? In this case, touching, i.e. the last beacon of the list is telling us we must take this path. We will keep adding beacons to the lists if the last beacon tell us to, until we eventually crossed paths: </p>
								<div>
									<figure>
										<img class="img-responsive" src="img/david/18.png">
									</figure>
									<div class="row">&nbsp;</div>
								</div>
								<p>In order to detect when we have “merged” the lists, which is something we know will happen, we will check, for example if we are adding the current beacon to the list 1 (i.e. we are heading towards P2), whether the two triangles we are peeling off are “influenced” by the beacon from the other list, list 2 in the case. If so, this would be the next beacon we would have to add, therefore we have already finished because we have found all the beacons in the path. Once we have found all the beacons required to route, this algorithm has finished.<br/>
								Finally, we have to arrange the two lists and join them in succession to build the actual path of beacons between the two points. We are done!</p>
							</div>
							<div id="d-applet">
								<h1>Applet</h1>
								<p>An applet has been implemented to illustrate the Sufficient Beacons algorithm. Click on the button below to use it. Instructions are included in the destination page.</p>
								<div class="row">&nbsp;</div>
									<div class="row">&nbsp;</div>
									<div class="centera">
										<a id="draw" href="html/applet/david/index.html" class="btn-lg btn-danger">Applet</a>
									</div>
							</div>
							<div id="d-biblio">
								<h1>Bibliography</h1>
								<ol><li>M. Biro, J. Gao, J. Iwerks, I. Kostitsyna, and J. S. B. Mitchell. Combinatorics of beacon-based routing and coverage. Proc. the 25th Canadian Conf. Comput. Geom. (CCCG 2013), 2013.</li></ol>
								<h3>Algorithm</h3>
								<ol>
									<li>Emo Welzl. Lecture notes. Chapter 5: Plane Graphs and the DCEL. 2012</li>
									<li>Stefan Langerman. Lecture notes. Triangles and polygon triangulation. (Ear clipping method). Academic year 2015-2016.</li>
									<li>Two Ears Theorem. 2016. Wikipedia. https://en.wikipedia.org/wiki/Two_ears_theorem</li>
								</ol>
							</div>
							<div class="row">&nbsp;</div>
							<div class="row">&nbsp;</div>
						</div>
						</div>
					</div>
				</div>
				<div id="andrea" class="container-fluid tab-pane fade">
					<div class="row">
						<div class="row">&nbsp;</div>
						<div class="row">&nbsp;</div>
						<div class="col-sm-3">
							<nav id="myScrollspy">
							  <ul id="menu1" class="nav nav-pills nav-stacked well" data-spy="affix" data-offset-top="360">
								<li class="active"><a href="#a-intro">1 Introduction</a>									
								</li>
								<li><a href="#a-setting">2 Setting and Terminology</a>
								</li>
								<li><a href="#a-attr">3 The Attraction Region</a>
								</li>
								<li><a href="#a-inv">4 The Inverse Attraction Region</a>								
								</li>
								<li><a href="#a-route">5 Algorithms for Routing</a>								
								</li>
								<li><a href="#a-applet">6 Applet</a>
								</li>
								<li><a href="#a-ref">References</a>
								</li>
							  </ul>
							</nav>
						</div>
						<div class="col-sm-9">
							<div id="globalWrapper">
<script type="math/tex">
\newcommand{\lyxlock}{}
</script>
<noscript>
<div class="warning">
Warning: <a href="http://www.mathjax.org/">MathJax</a> requires JavaScript to correctly process the mathematics on this page. Please enable JavaScript on your browser.
</div><hr/>
</noscript>
<h1 id="a-intro" class="Section">
<a class="toc" name="toc-Section-1">1</a> Introduction
</h1>
<div id="a-intro" class="Unindented">
In this page we will look at how beacons interact with objects placed in a polygon. We will define relevant regions in a polygon, with respect to one or more beacons and interacting objects, namely the Attraction Region <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> of a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> and the Inverse Attraction Region <span class="MathJax_Preview"><script type="math/tex">
IA\left(p\right)
</script>
</span> of a point <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>, and we will look at their key properties. We will also see how to compute those regions, then we will give algorithms that exploit the knowledge of them to route an object starting at a position <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> until a final point <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span>.<br/>
The content of this page is re-elaborated from <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span> and <span class="bibcites">[<a class="bibliocite" name="cite-3" href="#biblio-3"><span class="bib-index">3</span></a>]</span>.<br/>
In Section <a class="Reference" href="#sec:Setting-and-Terminology">2↓</a> we describe the generic setting that we consider throughout the page and give basic definitions; in Section <a class="Reference" href="#sec:The-Attraction-Region">3↓</a> we define the Attraction Region of a beacon and give its properties and algorithms to compute it; in Section <a class="Reference" href="#sec:The-Inverse-Attraction">4↓</a> we discuss the Inverse Attraction Region of a point, following an outline that is similar to that of the previous section; Section <a class="Reference" href="#sec:Algorithms-for-Beacon-Based">5↓</a> presents two algorithms that route an object from a point <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> to a point <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span>. One requires a set of candidate intermediate beacons, the other is a polynomial-time approximation of the optimal routing path. Finally, in Section <a class="Reference" href="#sec:Applet">6↓</a>, we provide the link to an applet that allows to experiment with the concepts described in this page.
</div>
<h1 id="a-setting"  class="Section">
<a class="toc" name="toc-Section-2">2</a> Setting and Terminology<a class="Label" name="sec:Setting-and-Terminology"> </a>
</h1>
<div class="Unindented">
All the terminology and mathematical statements in this Section are taken from <span class="bibcites">[<a class="bibliocite" name="cite-3" href="#biblio-3"><span class="bib-index">3</span></a>]</span> and <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span>.<br/>
We consider a <i>polygon</i> <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, not self-intersecting, possibly with holes, whose boundary edges are oriented counterclockwise (the edges of a hole are instead oriented clockwise). A <i>beacon</i> <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> is a point in the interior of <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> that can be activated to exercise a ’magnetic pull’ on an object initially placed at a point <span class="MathJax_Preview"><script type="math/tex">
p\in P
</script>
</span>. <div class="float">
<a class="Label" name="Figure-1"> </a><div class="figure">
<img class="embedded" src="img/andrea/1.png" alt="figure 1.png" style="width: 423px; max-width: 847px; height: 337px; max-height: 674px;"/>
<div class="caption">
Figure 1 A beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> excercises a ’magnetic pull’ on a point <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>.
</div>

</div>

</div>
<br/>
When <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> is active, the object decreases its Euclidean distance from <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> greedily, following a straight line towards <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> until it reaches either <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> or <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span>. In the second case, it slides along <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span>, provided that its distance from <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> decreases monotonically. When the object is no more constrained by <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span>, it moves again in a straight line. Thus, a generic route from a point <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> to a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> alternates between these described modes.<div class="float">
<a class="Label" name="Figure-2"> </a><div class="figure">
<img class="embedded" src="img/andrea/2.png" alt="figure 2.png" style="width: 450px; max-width: 1125px; height: 526px; max-height: 1317px;"/>
<div class="caption">
Figure 2 An object starting at <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> moves unconstrained <br/>
unless it meets <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span>, then it slides along it.
</div>

</div>

</div>
<br/>
If the object reaches a point in which the distance from <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> cannot decrease that is different from<span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, we say the object is <i>stuck</i>. The reached point is called a <i>dead point</i> on <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> for beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>. The set of dead points for <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> is referred to as <span class="MathJax_Preview"><script type="math/tex">
D\left(b\right)
</script>
</span>. If an object starting at <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is able to reach <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, we say that <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> <i>attracts</i> <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> (<span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> <i>is attracted to</i> <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>).<br/>
When routing an object from a starting point <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> to a destination <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span>, we use a set <span class="MathJax_Preview"><script type="math/tex">
M
</script>
</span> of beacon points, which we activate in sequence: only one beacon at a time is active, and it remains active until it is reached by the object. At that point the next beacon is activated and the old one is simultaneously deactivated. We say that <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span> are <i>routed</i> if we can find a set <span class="MathJax_Preview"><script type="math/tex">
M'
</script>
</span> of beacon points that, when activated in the right sequence, can route an object from <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> to <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span>. See Figure <a class="Reference" href="#fig:routed">3↓</a> for an example.<div class="float">
<a class="Label" name="fig:routed"> </a><div class="figure">
<img class="embedded" src="img/andrea/5.png" alt="figure 5.png" style="width: 947px; max-width: 1895px; height: 560px; max-height: 1121px;"/>
<div class="caption">
Figure 3 <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span> are routed.
</div>

</div>

</div>
<br/>
Given a dead point <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span> and a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, we call <span class="MathJax_Preview"><script type="math/tex">
DR_{b}\left(d\right)
</script>
</span> the <i>dead region</i> of <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span> with respect to <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, which we define as the set of points <span class="MathJax_Preview"><script type="math/tex">
p\in P
</script>
</span> that will eventually get stuck at <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span> under the influence of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>. There are two types of dead points: vertex dead points and edge dead points.<div class="float">
<a class="Label" name="Figure-4"> </a><div class="multifigure">
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/6.png" alt="figure 6.png" style="width: 404px; max-width: 1037px; height: 436px; max-height: 1119px;"/>
<div class="caption">
(a) The dead region of <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span> is shown in red.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/3.png" alt="figure 3.png" style="width: 420px; max-width: 1077px; height: 441px; max-height: 1133px;"/>
<div class="caption">
(b) <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span> is a vertex dead point.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/4.png" alt="figure 4.png" style="width: 474px; max-width: 1185px; height: 436px; max-height: 1091px;"/>
<div class="caption">
(c) <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span> is an edge dead point.
</div>

</div>

</span>
<div class="caption">
Figure 4 Types of dead points.
</div>

</div>

</div>
<br/>
We can distinguish points belonging to <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> as <i>odd boundary points </i>or <i>even boundary points, </i>depending on whether an object placed at them moves unconstrained or along <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> under the influence of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>. Can we characterize even and odd boundary points in some other way? Yes, as the following proposition states. This characterization will be useful later.
</div>
<div class="Proposition"><div class="row">&nbsp;</div>
<p><b>Proposition 2.1. </b><i>
Given a poligon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, a point <span class="MathJax_Preview"><script type="math/tex">
p\in\partial P
</script>
</span> and a beacon <span class="MathJax_Preview"><script type="math/tex">
b\in P
</script>
</span>, <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is an odd (even) boundary point with respect to <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> if and only if the line segment <span class="MathJax_Preview"><script type="math/tex">
\overline{bp}
</script>
</span> crosses <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> an odd (even) number of times.
</i></p>
</div>
<div class="Proof">
<i>Proof. </i>
Let us consider the line segment <span class="MathJax_Preview"><script type="math/tex">
\overline{bp}
</script>
</span> . Let us assume it crosses <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> <span class="MathJax_Preview"><script type="math/tex">
k
</script>
</span> times. We have that the crossings divide <span class="MathJax_Preview"><script type="math/tex">
\overline{bp}
</script>
</span> into <span class="MathJax_Preview"><script type="math/tex">
k+1
</script>
</span> segments. The first one lies of course entirely in <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, and the same holds for all odd numbered segments. Conversely, all even numbered segments lie outside <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>. Now, if <span class="MathJax_Preview"><script type="math/tex">
\overline{bp}
</script>
</span> crosses <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> an even number of times, counting <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> as a crossing, the final segment before <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> lies outside <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, thus an object at <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> cannot move along <span class="MathJax_Preview"><script type="math/tex">
\overline{bp}
</script>
</span> because it is constrained by the edge(s) containing <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>, making <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> an even boundary point. On the other hand, if <span class="MathJax_Preview"><script type="math/tex">
\overline{bp}
</script>
</span> crosses <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> an odd number of times, the last segment is inside <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, making <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> an odd boundary point.
</div>
<div class="--Separator--">
From the previous proposition we get the following Corollary.
</div>
<div class="Corollary">
<div class="row">&nbsp;</div>
<p><b>Corollary 2.2. </b><i>Given a dead point <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span> with respect to a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> in a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, the line segment <span class="MathJax_Preview"><script type="math/tex">
\overline{bd}
</script>
</span> intersects <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> an even number of times. &#8718;
</i></p>
</div>
<div class="Unindented">
Another useful Theorem (see <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span> for its proof) bounds the number of dead points that can be found on an edge.
</div>
<div class="Theorem"><div class="row">&nbsp;</div>
<p><b>Theorem 2.3. </b><i>Given an edge <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> of <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span>, <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> contains at most <span class="MathJax_Preview"><script type="math/tex">
1
</script>
</span> dead point.
</i></p>
</div>
<h1 id="a-attr" class="Section">
<a class="toc" name="toc-Section-3">3</a> The Attraction Region<a class="Label" name="sec:The-Attraction-Region"> </a>
</h1>
<div class="Unindented">
All the terminology and mathematical statements in this Section are taken from <span class="bibcites">[<a class="bibliocite" name="cite-3" href="#biblio-3"><span class="bib-index">3</span></a>]</span> and <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span>.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.1">3.1</a> Definition
</h2>
<div class="Unindented">
The Attraction Region of a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> is defined as follows:
</div>
<div class="Definition"><div class="row">&nbsp;</div>
<p><b>Definition 3.1. </b><i>The Attraction Region <span class="MathJax_Preview"><script type="math/tex">
A(b)
</script>
</span> of a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> is the set of points <span class="MathJax_Preview"><script type="math/tex">
p\in P
</script>
</span> that are attracted to <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>.
</i></p>
</div>
<div class="Definition">
<div class="float">
<a class="Label" name="Figure-5"> </a><div class="figure">
<img class="embedded" src="img/andrea/7.png" alt="figure 7.png" style="width: 662px; max-width: 1657px; height: 613px; max-height: 1533px;"/>
<div class="caption">
Figure 5 The attraction region of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> is shown in green.
</div>

</div>

</div>

</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.2">3.2</a> Properties
</h2>
<div class="Unindented">
We would like to obtain insights on how to easily define the boundaries of Attraction Regions, so we explore some of their properties, but also the properties of other related entities.<br/>
Let’s start by asking ourselves how many dead points are there, given a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>. The following theorems give us tight bounds, distinguishing between polygons without or with holes.
</div>
<div class="Theorem"><div class="row">&nbsp;</div>
<p><b>Theorem 3.2. </b><i>Given a simple polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> with <span class="MathJax_Preview"><script type="math/tex">
n
</script>
</span> vertices, we have <span class="MathJax_Preview"><script type="math/tex">
0\leq\left|D(b)\right|\leq n-3
</script>
</span>.
</i></p>
</div>
<div class="Proof">
<i>Proof. </i>
If <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> is convex it has no dead points, so the lower bound can be easily observed. For the upper bound, consider a beacon <span class="MathJax_Preview"><script type="math/tex">
b\in P
</script>
</span>. It can be easily seen that at least <span class="MathJax_Preview"><script type="math/tex">
3
</script>
</span> edges of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> are visible to <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, so any ray starting from <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> that crosses these edges would cross them first. Thus we would have an odd number of crossings for each of these three edges, that consequently cannot contain dead points. Finally, an edge contains at most <span class="MathJax_Preview"><script type="math/tex">
1
</script>
</span> dead point, so the given upper bound holds. See Figure <a class="Reference" href="#fig:dead-bound">a↓</a> for an example. &#8718;
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-6"> </a><div class="multifigure">
<span class="float">
<a class="Label" name="fig:dead-bound"> </a><div class="figure">
<img class="embedded" src="img/andrea/8.png" alt="figure 8.png" style="width: 390px; max-width: 781px; height: 799px; max-height: 1598px;"/>
<div class="caption">
(a) <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> has <span class="MathJax_Preview"><script type="math/tex">
7-3=n-3=4
</script>
</span> dead points.
</div>

</div>

</span>
<span class="float">
<a class="Label" name="fig:dead-holes"> </a><div class="figure">
<img class="embedded" src="img/andrea/9.png" alt="figure 9.png" style="width: 400px; max-width: 817px; height: 792px; max-height: 1618px;"/>
<div class="caption">
(b) <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> has <span class="MathJax_Preview"><script type="math/tex">
13-2-3=n-h-3=8
</script>
</span> dead points.
</div>

</div>

</span>
<div class="caption">
Figure 6 Polygons showing that the upper bounds for dead points are reachable.<br/>
(Images adapted from <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span>)
</div>

</div>

</div>

</div>
<div class="Theorem"><div class="row">&nbsp;</div>
<p><b>Theorem 3.2. </b><i>Given a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> with <span class="MathJax_Preview"><script type="math/tex">
n
</script>
</span> vertices and <span class="MathJax_Preview"><script type="math/tex">
h
</script>
</span> holes, we have <span class="MathJax_Preview"><script type="math/tex">
0\leq\left|D(b)\right|\leq n-h-3
</script>
</span>.
</i></p>
</div>
<div class="Proof">
<i>Proof. </i>
This time we can observe the lower bound by taking a convex polygon with the holes being only triangles, oriented so that they don’t have any dead points. For the upper bound, first imagine to remove the holes from <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> and consider the resulting simple polygon <span class="MathJax_Preview"><script type="math/tex">
P'
</script>
</span>. If <span class="MathJax_Preview"><script type="math/tex">
n_{i}
</script>
</span> is the number of vertices of the <span class="MathJax_Preview"><script type="math/tex">
i
</script>
</span>th hole, then <span class="MathJax_Preview"><script type="math/tex">
P'
</script>
</span> has <span class="MathJax_Preview"><script type="math/tex">
n-\sum_{i}n_{i}
</script>
</span> vertices. <span class="MathJax_Preview"><script type="math/tex">
b\in P
</script>
</span> so <span class="MathJax_Preview"><script type="math/tex">
P'
</script>
</span> has at most <span class="MathJax_Preview"><script type="math/tex">
n-\sum_{i}n_{i}-3
</script>
</span>. Now consider a hole <span class="MathJax_Preview"><script type="math/tex">
i
</script>
</span>, with <span class="MathJax_Preview"><script type="math/tex">
n_{i}
</script>
</span> vertices, and <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> alone. At least one edge of <span class="MathJax_Preview"><script type="math/tex">
i
</script>
</span> is visible to <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, thus <span class="MathJax_Preview"><script type="math/tex">
i
</script>
</span> can have at most <span class="MathJax_Preview"><script type="math/tex">
n_{i}-1
</script>
</span>dead points on its boundary. The same holds for the other holes. By summing up the individual contributions, we get <span class="MathJax_Preview"><script type="math/tex">
\sum_{i}\left(n_{i}-1\right)=\left(\sum_{i}n_{i}\right)-h
</script>
</span>. If we combine this result with the one for the ploygon without holes we get <span class="MathJax_Preview"><script type="math/tex">
n-\sum_{i}n_{i}-3+\sum_{i}n_{i}-h=n-h-3
</script>
</span> dead points. See figure <a class="Reference" href="#fig:dead-holes">b↑</a> for an example. &#8718;
</div>
<div class="Unindented">
<div class="row">&nbsp;</div>
Thanks to these theorems, we can limit the number of dead points for a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, thus we can also limit the number of its dead regions. We take a step further towards our goal by stating that the dead regions of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> togheter with <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> form a partition of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>.
</div>
<div class="Theorem"><div class="row">&nbsp;</div>
<p><b>Theorem 3.4. </b><i>The dead regions of a beacon<span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> in a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, along with <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> partition <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>.</i></p>
<a class="Label" name="thm:The-dead-regions"> </a>
</div>
<div class="Proof">
<i>Proof. </i>
First of all, an object starting at a point in <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> will either reach <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> or a dead point <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span>, thus fulfilling the requirement that the regions taken togheter yeld <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>. It remains to show that these regions don’t overlap. In a situation as that of Figure <a class="Reference" href="#fig:disambiguation">a↓</a>, our definitions are not enough precise to decide along which edge incident to a reflex vertex <span class="MathJax_Preview"><script type="math/tex">
v
</script>
</span> an object at <span class="MathJax_Preview"><script type="math/tex">
v
</script>
</span> will slide. The problem is eliminated by adopting the convention that objects at <span class="MathJax_Preview"><script type="math/tex">
v
</script>
</span> go always left. We have ensured that an object will follow a unique path under the influence of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>: <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> is subdivided into disjoint regions. From what we said, each point is located in a region, so the proof is complete. &#8718;
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-7"> </a><div class="multifigure">
<span class="float">
<a class="Label" name="fig:disambiguation"> </a><div class="figure">
<img class="embedded" src="img/andrea/10.png" alt="figure 10.png" style="width: 334px; max-width: 669px; height: 510px; max-height: 1021px;"/>
<div class="caption">
(a) We arbitrarily decide that <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> goes always left.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/11.png" alt="figure 11.png" style="width: 565px; max-width: 1529px; height: 468px; max-height: 1265px;"/>
<div class="caption">
(b) An example partition, induced by <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>.<br/>
The attraction region is in green, the dead <br/>
regions with their respective dead points are in red.
</div>

</div>

</span>
<div class="caption">
Figure 7 Visualization of the arguments of Theorem <a class="Reference" href="#thm:The-dead-regions">3.2↑</a>.
</div>

</div>

</div>
<br/>
This result gives us an interesting hint, because it tells us that to identify <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> we can try to determine the edges of the partition induced by <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>. How to do this? It turns out that we need to use a particular kind of vertices in <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, called split vertices. We elaborate on them in the next Subsection.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.3">3.3</a> Split Vertices<a class="Label" name="sub:Split-Vertices"> </a>
</h2>
<div class="Unindented">
We start by defining <i>cut vertices</i>, which are a particular case of reflex vertices.
</div>
<div class="Definition"><div class="row">&nbsp;</div>
<p><b>Definition 3.5. </b><i>Given a reflex vertex <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>, we say that <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is a cut vertex if the ray <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp}
</script>
</span> with its origin translated to <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> cuts the interior of <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> starting immediately from <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>.
</i></p>
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-8"> </a><div class="figure">
<img class="embedded" src="img/andrea/12.png" alt="figure 12.png" style="width: 378px; max-width: 757px; height: 324px; max-height: 649px;"/>
<div class="caption">
Figure 8 <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is a cut vertex.
</div>

</div>

</div>
<br/>
How do we recognize a cut vertex? We can simply compute two cross products, as the next proposition precises.
</div>
<div class="Proposition"><div class="row">&nbsp;</div>
<p><b>Proposition 3.6. </b><i>Given a reflex vertex <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span>, we say it is a cut vertex if:
</div>
<div class="Proposition">
1. <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\times\overrightarrow{p_{i}p_{i+1}}<0
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\times\overrightarrow{p_{i-1}p_{i}}<0
</script>
</span> (Class I)
</div>
<div class="Proposition">
2. <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\times\overrightarrow{p_{i}p_{i+1}}>0
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\times\overrightarrow{p_{i-1}p_{i}}<0
</script>
</span> (Class II)
</div>
<div class="Proposition">
3. <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\times\overrightarrow{p_{i}p_{i+1}}<0
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\times\overrightarrow{p_{i-1}p_{i}}>0
</script>
</span> (Class III)
</i></p>
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-9"> </a><div class="multifigure">
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/13.png" alt="figure 13.png" style="width: 266px; max-width: 533px; height: 335px; max-height: 671px;"/>
<div class="caption">
(a) <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is Class I cut vertex.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/14.png" alt="figure 14.png" style="width: 383px; max-width: 723px; height: 331px; max-height: 625px;"/>
<div class="caption">
(b) <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is Class II cut vertex.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/15.png" alt="figure 15.png" style="width: 358px; max-width: 703px; height: 328px; max-height: 645px;"/>
<div class="caption">
(c) <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is Class III cut vertex.
</div>

</div>

</span>
<div class="caption">
Figure 9 Types of cut vertices.
</div>

</div>

</div>
<br/>
Now, a split vertex is just a particular case of cut vertex. We can identify it just by computing some additional dot products:
</div>
<div class="Proposition"><div class="row">&nbsp;</div>
<p><b>Proposition 3.7. </b><i>Given a cut vertex <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span>, we say it is a split vertex if and only if:
</div>
<div class="Proposition">
1. It is a class I cut vertex and <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\cdot\overrightarrow{p_{i}p_{i+1}}<0
</script>
</span>, <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\cdot\overrightarrow{p_{i-1}p_{i}}>0
</script>
</span>b
</div>
<div class="Proposition">
2. It is a class II cut vertex and <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\cdot\overrightarrow{p_{i-1}p_{i}}>0
</script>
</span>
</div>
<div class="Proposition">
3. It is a class III cut vertex and <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\cdot\overrightarrow{p_{i}p_{i+1}}<0
</script>
</span>
</i></p>
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-10"> </a><div class="multifigure">
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/13.png" alt="figure 13.png" style="width: 266px; max-width: 533px; height: 335px; max-height: 671px;"/>
<div class="caption">
(a) <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is a Class I cut vertex and a split vertex.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/16.png" alt="figure 16.png" style="width: 294px; max-width: 627px; height: 336px; max-height: 717px;"/>
<div class="caption">
(b) <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is a Class II cut vertex and a split vertex.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/17.png" alt="figure 17.png" style="width: 324px; max-width: 649px; height: 331px; max-height: 663px;"/>
<div class="caption">
(c) <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is a Class III cut vertex and a split vertex.
</div>

</div>

</span>
<div class="caption">
Figure 10 Types of split vertices.
</div>

</div>

</div>
<br/>
Given a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> and a split vertex <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> with respect to <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, we can identify the corresponding <i>split edge</i> by considering the first intersection of the ray <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}
</script>
</span> starting at <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> with <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span>, which we call the <i>ray vertex</i>. Split edges play a central role in the partition induced by a beacon: they are the boundary between two adjacent regions (although in polygons wih holes they might be entirely contained in a region).<br/>
<div class="float">
<a class="Label" name="Figure-11"> </a><div class="figure">
<img class="embedded" src="img/andrea/19.png" alt="figure 19.png" style="width: 450px; max-width: 901px; height: 418px; max-height: 837px;"/>
<div class="caption">
Figure 11 <span class="MathJax_Preview"><script type="math/tex">
v
</script>
</span> is the ray vertex correspoinding to <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>. <span class="MathJax_Preview"><script type="math/tex">
\overline{pv}
</script>
</span> is a split edge.
</div>

</div>

</div>

</div>
<div class="Theorem"><div class="row">&nbsp;</div>
<p><b>Theorem 3.8. </b><i>Given a simple polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> and one of its split edges <span class="MathJax_Preview"><script type="math/tex">
e=\overline{p_{i}q_{i}}
</script>
</span> with respect to a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> (<span class="MathJax_Preview"><script type="math/tex">
q_{i}
</script>
</span> is the ray vertex), <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> represents the boundary between two dead regions or between <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> and a dead region. This might not be the case for a polygon with holes, where <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> might be entirely contained in the interior of <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> or a dead region, but it can intersect at most one region.</i></p>
<a class="Label" name="thm:Given-a-simple"> </a>
</div>
<div class="Proof">
<i>Proof. </i>
Consider first the case where <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> is simple. Then <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> represents a diagonal of <span class="MathJax_Preview"><script type="math/tex">
P+q_{i}
</script>
</span>. This polygon is divided into two parts, that we call <span class="MathJax_Preview"><script type="math/tex">
P_{L}
</script>
</span>and <span class="MathJax_Preview"><script type="math/tex">
P_{R}
</script>
</span>. We need to figure out how an object could possibly cross <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> under the attracion of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, and show that any possible case is infeasible. Objects placed on <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> will eventually reach <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> and slide left, because of our convention. What’s more, an object moving unconstrained under the influence of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> could never cross <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> and switch between <span class="MathJax_Preview"><script type="math/tex">
P_{L}
</script>
</span>and <span class="MathJax_Preview"><script type="math/tex">
P_{R}
</script>
</span>, because <span class="MathJax_Preview"><script type="math/tex">
e
</script> is parallel to the ray <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}
</script>
</span>. It remains to handle the case where the objects starts sliding along <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span>. But the crossing of <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> cannot happen here, because of the following argument. <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> is a split vertex; this means that objects sliding along the edges adjacent to <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> move away from it, thus if they are on differents sides of <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span>, they are in different regions. <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> is on the the boundary of at most two regions, because the points on a ray move unconstrained until they all meet <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> at the same location, meaning that they will end up in the same point. Thus rays on different sides of <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> are in different regions, that have <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> as boundary.<br/>
If <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> has holes, some points on different sides of <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> could slide around a hole and end up in the same location, causing <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> to be contained in a region. &#8718;
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-12"> </a><div class="multifigure">
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/20.png" alt="figure 20.png" style="width: 540px; max-width: 1081px; height: 512px; max-height: 1025px;"/>
<div class="caption">
(a) An object starting at <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> and moving unconstrained can never cross <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span>.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/21.png" alt="figure 21.png" style="width: 470px; max-width: 941px; height: 516px; max-height: 1033px;"/>
<div class="caption">
(b) An object starting at <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> and reaching <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> will always move away from <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span>.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/22.png" alt="figure 22.png" style="width: 560px; max-width: 1121px; height: 566px; max-height: 1133px;"/>
<div class="caption">
(c) Objects on the same ray cast from <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> end in the same point.
</div>

</div>

</span>
<div class="caption">
Figure 12 Visualization of the arguments of Theorem <a class="Reference" href="#thm:Given-a-simple">3.3↑</a>
</div>

</div>

</div>
<br/>
We are now close to a correct description of a partition induced by a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> on a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>. In addition to split edges, we need to say something about the edges of <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span>, and establish which kind of edges can form the partition.
</div>
<div class="Theorem"><div class="row">&nbsp;</div>
<p><b>Theorem 3.9. </b><i>A boundary edge of a region in the partition of a simple polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> induced by a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> can be either:
</div>
<div class="Theorem">
1. An edge of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> that has not been divided by a split edge
</div>
<div class="Theorem">
2. A split edge
</div>
<div class="Theorem">
3. An edge of the form <span class="MathJax_Preview"><script type="math/tex">
\left(p_{k},q_{i}\right)
</script>
</span>, <span class="MathJax_Preview"><script type="math/tex">
\left(q_{i},p_{l}\right)
</script>
</span> or <span class="MathJax_Preview"><script type="math/tex">
\left(q_{i},q_{j}\right)
</script>
</span>, with <span class="MathJax_Preview"><script type="math/tex">
q_{i}
</script>
</span>and <span class="MathJax_Preview"><script type="math/tex">
q_{j}
</script>
</span> adjacent ray vertices lying on the edge <span class="MathJax_Preview"><script type="math/tex">
e=\left(p_{k},p_{l}\right)
</script>
</span>.</i></p>
<a class="Label" name="thm:3.-An-edge"> </a>
</div>
<div class="Proof">
<i>Proof. </i>
For simple polygons, let us start by noticing that all the edges are on the boundary of one or more regions, because all the points in <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> belong to the partition. We have already talked about split edges. We can easily notice that the edges descibed at the third element of our list are components of an edge of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, that have been split by one or more ray vertices, in such a way that they are on the boundary of only one region, while the original edge <span class="MathJax_Preview"><script type="math/tex">
\left(p_{k},p_{l}\right)
</script>
</span>is on the boundary of a different region per different component. We are not done yet; we need to show that no other type of edge can be on the boundary of a region. Let us imagine that there exists a component <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> on the boundary of a region that isn’t of any type mentioned so far. First, it cannot be that any part of <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> isn’t parallel to a ray casted from the beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> that intesects <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span>, because otherwise objects on some points of the ray would move unconstrained until they would cross <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span>, thus sharing the region of the points on the other side of <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> . We also have to take into account that <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> would intersect <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> at two points, that we may call <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
s_{2}
</script>
</span>. Assume that <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span> is the closer to <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> between the two. Where is <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span>? It turns out that it must be a vertex of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>. Points on <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> will reach <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span>. If <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span> was in the interior of an edge of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, we would have crossings of <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span>: in case <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span> was a dead point, objects from either side would get stuck at <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span>, in case not, objects would slide along the edge containing <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span>, ending again at the same dead point. Now if we think about which of the elements of our list has the characteristics of <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> (acting as a separator of the points on different sides), we see that it is exactly a split edge, with <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span> as the split vertex.<br/>
In a polygon with holes, it might happen that some split edges or components of divided edges are not on the boundary of a region. &#8718;
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-13"> </a><div class="multifigure">
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/23.png" alt="figure 23.png" style="width: 320px; max-width: 256px; height: 513px; max-height: 411px;"/>
<div class="caption">
(a) If <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> wasn’t entirely parallel to <br/>
a ray cast from <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> that crosses it, <br/>
some points would cross <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span>.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/24.png" alt="figure 24.png" style="width: 315px; max-width: 685px; height: 410px; max-height: 893px;"/>
<div class="caption">
(b) <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span> cannot be an edge dead point,<br/>
 because otherwise points on<br/>
different sides of <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> would reach it.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="img/andrea/25.png" alt="figure 25.png" style="width: auto; max-width: 585px; height: 10.3cm; max-height: 1049px;"/>
<div class="caption">
(c) <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span> cannot be on an edge in<br/>
general, because otherwise <br/>
some points would cross it and <br/>
go into the adjacent region.
</div>

</div>

</span>
<div class="caption">
Figure 13 Visualization of the arguments of Theorem <a class="Reference" href="#thm:3.-An-edge">3.3↑</a>
</div>

</div>

</div>
<br/>
Now we can define a concrete strategy for obtaining the attraction region algorithmically! Given a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> and a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, first we need to find the split vertices of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> with respect to <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, then compute the corresponding ray vertices to obtain the split edges and the components of the divided edges of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>. In case of a polygon with holes this is not enough; we also need to discard the edges that we meet twice when walking along the boundaries of the regions. By doing this we will obtain a set of regions, namely the dead regions, each containing a different dead point, and the attraction region.<br/>
There are a few more properties of the attraction region of a beacon that are worth mentioning; we give them in the next Subsection.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.4">3.4</a> Additional Properties
</h2>
<div class="Proposition"><div class="row">&nbsp;</div>
<p><b>Proposition 3.10. </b><i>If <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> is a beacon, <span class="MathJax_Preview"><script type="math/tex">
b\epsilon A\left(b\right)
</script>
</span>. Moreover, if <span class="MathJax_Preview"><script type="math/tex">
V\left(b\right)
</script>
</span> is the visibility polygon of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, we have that <span class="MathJax_Preview"><script type="math/tex">
V\left(b\right)\subseteq A\left(b\right)
</script>
</span> (equality might hold as well).
</i></p>
</div>
<div class="Theorem"><div class="row">&nbsp;</div>
<p><b>Theorem 3.11. </b><i>Given a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> is connected.
</i></p>
</div>
<div class="--Separator--">

</div>
<div class="Theorem"><div class="row">&nbsp;</div>
<p><b>Theorem 3.12. </b><i>Given a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> is convex with respect to <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, if <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> is simple (not necessarily if it has holes).
</i></p>
</div>
<div class="--Separator--">

</div>
<div class="Corollary">
<div class="row">&nbsp;</div>
<p><b>Corollay 3.13. </b><i>Given a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> has no holes, if <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> is simple (not necessarily if it has holes).
</i></p>
</div>
<div class="Theorem"><div class="row">&nbsp;</div>
<p><b>Theorem 3.14. </b><i>The partition of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> induced by a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> has boundary complexity <span class="MathJax_Preview"><script type="math/tex">
O\left(n\right)
</script>
</span>, as well as <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span>. There exist cases where <span class="MathJax_Preview"><script type="math/tex">
\Omega\left(n\right)
</script>
</span> holds to.
</i></p>
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.5">3.5</a> Algorithms for the Attraction Region
</h2>
<div class="Unindented">
In this subsection we review the existing algorithms for computing the attraction region of a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> in a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>. There are four algorithms in total. We will describe in detail only the first one, which is the one that was implented. In the complexity analyses, <span class="MathJax_Preview"><script type="math/tex">
n
</script>
</span> refers to the number of vertices of a polygon.
</div>
<h3 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-3.5.1">3.5.1</a> Algorithm 1
</h3>
<div class="Unindented">
This algorithm exploits the idea that we mentioned in Subsection <a class="Reference" href="#sub:Split-Vertices">3.3↑</a>. It employs a rotational sweep technique. First it sorts the vertices of a polygon radially about a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, then it examines the sorted list to find split vertices, maintining a status of the edges intersecting the sweep line in order of increasing distance from the beacon. Once a split vertex is found, it determines the corresponding ray vertex. In the end it will yeld the partition induced by the beacon. For a polygon with holes, we have to be careful excluding edges contained in a region, as we mentioned in Subsection <a class="Reference" href="#sub:Split-Vertices">3.3↑</a>. We now give the pseudocode of the algorithm.
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--1"></a><div class="float">
<a class="Label" name="alg:Algo1"> </a><div class="algorithm">
<div class="listing">
<pre class="listing"><span class="number-left">1</span>procedure AttractionRegion(P, b)
<span class="number-left">2</span>	Sort the vertices by angle about b, and keep in an ordered event list L=(p1, p2, ..., pn)     
<span class="number-left">3</span>	Find the order of intersection of edges from p1 along the ray bp1 and store as status S
<span class="number-left">4</span>	for the next vertex pi in L do
<span class="number-left">5</span>		Update S as necessary
<span class="number-left">6</span>		if pi is a split vertex with respect to b then
<span class="number-left">7</span>			Find qi, the ray-vertex of pi with respect to b
<span class="number-left">8</span>			Add qi to the arrangement of P
<span class="number-left">9</span>			Add edge (pi, qi) to the arrangement of P
<span class="number-left">10</span>		end if
<span class="number-left">11</span>	end for
<span class="number-left">12</span>	return the arrangement of P
<span class="number-left">13</span>end procedure
</pre>
</div>
<div class="caption">
Algorithm 1 <span class="MathJax_Preview"><script type="math/tex">
O(n\log n)
</script>
</span> running-time algorithm in simple polygons (taken from <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span>)
</div>

</div>

</div>
<br/>
<div class="row">&nbsp;</div>
Complexity analysis
</div>
<div class="Unindented">
The algorithm requires a comparison-based sorting algorithm in order to obtain the ordered list of points. Since a comparisons can be done in constant time using turns, the sorting part takes <span class="MathJax_Preview"><script type="math/tex">
O(n\log n)
</script>
</span> as usual. Maintining a sweep line status also costs <span class="MathJax_Preview"><script type="math/tex">
O(n\log n)
</script>
</span>. Determining if a vertex is a split vertex takes constant time (we saw how to do this in Subsection <a class="Reference" href="#sub:Split-Vertices">3.3↑</a>). Finding the ray vertex also takes constant time, because we can exploit the sweep line status to find the edge on which it lies.<br/>
In polygons with holes, the time spent walking on regions’ boundaries is linear, so it is dominated, for instance, by the sorting algorithm.<br/>
The space complexity is <span class="MathJax_Preview"><script type="math/tex">
O(n)
</script>
</span>, because we can only find <span class="MathJax_Preview"><script type="math/tex">
O(n)
</script>
</span> split edges and, consequently, <span class="MathJax_Preview"><script type="math/tex">
O(n)
</script>
</span> components of divided edges.
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--2"></a><div class="row">&nbsp;</div>Implementation
</div>
<div class="Unindented">
In our implementation, we used a modified version of the quicksort algorithm in order to obtain the ordered event list, and we used a red-black binary search tree to maintain the sweep line status. An input polygon is stored and updated during the algorithm by using a doubly connected edge list. Adding a split edge and splitting the edge on which its ray vertex lies is achieved by a split-edge operation using the ray vertex, followed by a split-face that adds the split edge. It is worth mentioning that Algorithm <a class="Reference" href="#alg:Algo1">1↑</a> contains a little error. At line <span class="MathJax_Preview"><script type="math/tex">
3
</script>
</span>, we are asked to find the edges that intersect the ray <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{1}}
</script>
</span> with its origin translated at <span class="MathJax_Preview"><script type="math/tex">
p{}_{1}
</script>
</span>, but in this way we might miss some edges that we would need to take into account when processing a split vertex <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> coming after and that we wouldn’t be able to meet as the sweep line advances from <span class="MathJax_Preview"><script type="math/tex">
p_{1}
</script>
</span> to <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span>. See Figure <a class="Reference" href="#fig:algo-wrong">14↓</a> for an example. This error caused crashes in the implementation and it can be solved by including in the status the edges intersecting <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{1}}
</script>
</span> with its origin at <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="fig:algo-wrong"> </a><div class="figure">
<img class="embedded" src="img/andrea/29.png" alt="figure 29.png" style="width: 794px; max-width: 2269px; height: 546px; max-height: 1561px;"/>
<div class="caption">
Figure 14 The sweep line (shown in green) rotates counterclockwise. <br/>
The missed edges are shown in red.
</div>

</div>

</div>

</div>
<h3 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-3.5.2">3.5.2</a> Algorithm 2
</h3>
<div class="Unindented">
The second algorithm is similar to the first one, but in order to compute split edges it uses the geodesic triangulation data structure described in <span class="bibcites">[<a class="bibliocite" name="cite-1" href="#biblio-1"><span class="bib-index">1</span></a>]</span>, which we don’t treat here beacuse it is not directly related to the topic. Basically this data structure allows performing ray shooting queries efficiently, after some initial preprocessing, thus avoiding sorting and maintaining a sweepline status, in order to find ray vertices.
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--3"></a><div class="row">&nbsp;</div>Complexity analysis
</div>
<div class="Unindented">
Preprocessing the polygon for the geodesic triangulation takes <span class="MathJax_Preview"><script type="math/tex">
O(n\log n)
</script>
</span>, although it might be completed in linear time by using the fastest triangulation algorigthm known (see <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span>). A ray shooting query takes <span class="MathJax_Preview"><script type="math/tex">
O(\log n)
</script>
</span> for a split vertex and since we might have <span class="MathJax_Preview"><script type="math/tex">
\Theta\left(n\right)
</script>
</span> of them, we get a running time of <span class="MathJax_Preview"><script type="math/tex">
O(n\log n)
</script>
</span>.<br/>
In polygons with holes, the preprocessing time becomes <span class="MathJax_Preview"><script type="math/tex">
O\left(n\sqrt{h}+h^{\frac{3}{2}}\log h+n\log n\right)
</script>
</span>, while the query time is <span class="MathJax_Preview"><script type="math/tex">
O\left(\sqrt{h}\log n\right)
</script>
</span> (<span class="bibcites">[<a class="bibliocite" name="cite-1" href="#biblio-1"><span class="bib-index">1</span></a>]</span>). Thus, getting the raw arrangement takes <span class="MathJax_Preview"><script type="math/tex">
O\left(\sqrt{h}n\log n\right)
</script>
</span>, and it dominates the postprocessing time to eliminate false positives, which is linear as we explained before.<br/>
Space complexity is again <span class="MathJax_Preview"><script type="math/tex">
O(n)
</script>
</span>.
</div>
<h3 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-3.5.3">3.5.3</a> Algorithm 3
</h3>
<div class="Unindented">
The third algorithm is more involved. It starts by computing a triangulation of the input polygon, form which it obtains its dual graph, later transformed in a directed tree, which it uses to select only the edges on the boundary of the attraction region, that are obtained by discarding the split edges that are &ldquo;outside&rdquo; other split edges (the path from the beacon to them crosses other split edges). For each triangle we record the split edges that propagate through it. A split edge that is found to be on the boundary of the attraction region is propagated iteratively through the triangles containing it, which will eventually lead to finding the ray vertex. The attraction region is simply the region containing the beacon.<br/>
In polygons with holes we do the same as for the previous algorithms, but only for the attraction region. We don’t need to compute a triangulation that considers the holes of the polygon.
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--4"></a><div class="row">&nbsp;</div>Complexity Analysis
</div>
<div class="Unindented">
The initial triangulation can be computed in <span class="MathJax_Preview"><script type="math/tex">
O(n)
</script>
</span> time, thanks to the algorithm described in <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span>. Its dual, from which we obtain the directed tree and a list of interesting triangles can be obtained in linear time by performing a search from the triangle containing the beacon. Each triangle is considered once, and for each triangle we propagate at most two split edges (as the attraction reagon in a simple polygon is simple and all edges outside it are suddenly discarded), so we have a final running time equal to <span class="MathJax_Preview"><script type="math/tex">
O(n)
</script>
</span>.<br/>
For polygons with holes, the difference is that we would need to propagate <span class="MathJax_Preview"><script type="math/tex">
O(h)
</script>
</span> edges for each triangle, because of the holes, which might contribute with two split edges each, possibly propagated through many triangles. Thus the complexity becomes <span class="MathJax_Preview"><script type="math/tex">
O(hn)
</script>
</span>.<br/>
The triangulation , its dual, and the remaining data structures are all linear, so we get a space complexity of <span class="MathJax_Preview"><script type="math/tex">
O\left(n\right)
</script>
</span>.
</div>
<h3 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-3.5.4">3.5.4</a> Algorithm 4
</h3>
<div class="Unindented">
The last algorithm employs a radial trapezoidization (<span class="bibcites">[<a class="bibliocite" name="cite-7" href="#biblio-7"><span class="bib-index">7</span></a>]</span>). First it finds the visibility polygon of a beacon from the triangulation of the polygon, then it considers the remaining regions, for which it computes horizontal trapezoidizations in a projective space that brings the beacon to infinity. Reversing the projection yelds the radial trapezoidization of these regions. For each split vertex, use the trapezoidizations to find the ray vertex.
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--5"></a><div class="row">&nbsp;</div>Complexity Analysis
</div>
<div class="Unindented">
The radial trapezoidization can be computed in <span class="MathJax_Preview"><script type="math/tex">
O\left(n\right)
</script>
</span> time and the split edges can be found in <span class="MathJax_Preview"><script type="math/tex">
O\left(n\right)
</script>
</span> time too. Thus, the algorithm takes <span class="MathJax_Preview"><script type="math/tex">
O\left(n\right)
</script>
</span> time in total. In polygons with holes the complexity is dominated by the triangulation, that here considers also the holes and it’s computed in <span class="MathJax_Preview"><script type="math/tex">
O\left(n+h\log^{1+\epsilon}h\right)
</script>
</span>. Space complexity is linear as usual.
</div>
<h1 id="a-inv" class="Section">
<a class="toc" name="toc-Section-4">4</a> The Inverse Attraction Region<a class="Label" name="sec:The-Inverse-Attraction"> </a>
</h1>
<div class="Unindented">
All the terminology and mathematical statements in this Section are taken from <span class="bibcites">[<a class="bibliocite" name="cite-3" href="#biblio-3"><span class="bib-index">3</span></a>]</span> and <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span>.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-4.1">4.1</a> Definition
</h2>
<div class="Definition"><div class="row">&nbsp;</div>
<p><b>Definition 4.1. </b><i>Given a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> and a point <span class="MathJax_Preview"><script type="math/tex">
p\epsilon P
</script>
</span>, the inverse attraction region <span class="MathJax_Preview"><script type="math/tex">
IA\left(p\right)
</script>
</span> is the set of points in <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> to which <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is attracted (see Figure <a class="Reference" href="#fig:IA">15↓</a> for an example). </i></p>
</div>
<div class="Definition">
<div class="float">
<a class="Label" name="fig:IA"> </a><div class="figure">
<img class="embedded" src="img/andrea/27.png" alt="figure 27.png" style="width: 788px; max-width: 2253px; height: 477px; max-height: 1365px;"/>
<div class="caption">
Figure 15 <span class="MathJax_Preview"><script type="math/tex">
IA\left(p\right)
</script>
</span> is shown in purple.
</div>

</div>

</div>

</div>
<div class="--Separator--">

</div>
<div class="Definition"><div class="row">&nbsp;</div>
<p><b>Definition 4.2. </b><i>Given a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> and a subset <span class="MathJax_Preview"><script type="math/tex">
R
</script>
</span> of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, the inverse attraction region of <span class="MathJax_Preview"><script type="math/tex">
R
</script>
</span>, <span class="MathJax_Preview"><script type="math/tex">
IA\left(R\right)
</script>
</span>, is the set of points in <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> that attract at least one point in <span class="MathJax_Preview"><script type="math/tex">
R
</script>
</span>.
</i></p>
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-4.2">4.2</a> Algorithm for the Inverse Attraction Region of a Point<a class="Label" name="sub:Algorithm-Inverse"> </a>
</h2>
<div class="Unindented">
According to <span class="bibcites">[<a class="bibliocite" name="cite-3" href="#biblio-3"><span class="bib-index">3</span></a>, <a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span>, in order to obtain the inverse attraction region of a point <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>, we can consider a line arrangement induced by a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>, which we call <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{p}}
</script>
</span>, constructed by taking the following sets of lines:
</div>
<ol>
<li>
the lines defined by the edges of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>; 
</li>
<li>
for each reflex vertex, those lines intersecting it that are perpendicular to its incident edges;
</li>
<li>
lines through <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> and each reflex vertex.
</li>

</ol>
<div class="Unindented">
The authors of <span class="bibcites">[<a class="bibliocite" name="cite-3" href="#biblio-3"><span class="bib-index">3</span></a>, <a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span> claim some interesting properties for this arrangement that give ideas for an algorithm.
</div>
<div class="Lemma"><div class="row">&nbsp;</div>
<p><b>Lemma 4.3. </b><i></i></p>
Given two points <span class="MathJax_Preview"><script type="math/tex">
b_{1}
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
b_{2}
</script>
</span> contained in a face <span class="MathJax_Preview"><script type="math/tex">
F
</script>
</span> of <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{p}}
</script>
</span>, and given a vertex <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, if <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> is a split vertex for <span class="MathJax_Preview"><script type="math/tex">
b_{1}
</script>
</span> when we consider it as a beacon, then it is also a split vertex for <span class="MathJax_Preview"><script type="math/tex">
b_{2}
</script>
</span> .
</div>
<div class="Unindented">
This interesting fact can be used to prove a even stronger result:
</div>
<div class="Theorem"><div class="row">&nbsp;</div>
<p><b>Theorem 4.4. </b><i>Given two points <span class="MathJax_Preview"><script type="math/tex">
b_{1}
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
b_{2}
</script>
</span> contained in a face <span class="MathJax_Preview"><script type="math/tex">
F
</script>
</span> of <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{p}}
</script>
</span>, and given a point <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, if <span class="MathJax_Preview"><script type="math/tex">
p\epsilon A\left(b_{1}\right)
</script>
</span>, then <span class="MathJax_Preview"><script type="math/tex">
p\epsilon A\left(b_{2}\right)
</script>
</span> too.
</i></p>
</div>
<div class="Theorem">
<div class="float">
<a class="Label" name="fig:IA-wrong"> </a><div class="figure">
<img class="embedded" src="img/andrea/28.png" alt="figure 28.png" style="width: 528px; max-width: 1509px; height: 501px; max-height: 1433px;"/>
<div class="caption">
Figure 16 <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span> belong to the same face in <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{p}}
</script>
</span> but, while <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> cannot attract <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>,<br/>
 <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span> can. Also <span class="MathJax_Preview"><script type="math/tex">
s'
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
t'
</script>
</span> are in the same face, but <span class="MathJax_Preview"><script type="math/tex">
s'
</script>
</span> attracts <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
t'
</script>
</span><br/>
dg does not. (Image redrawn from <span class="bibcites">[<a class="bibliocite" name="cite-2" href="#biblio-2"><span class="bib-index">2</span></a>]</span>)
</div>

</div>

</div>

</div>
<div class="Unindented">
This is a great simplification, because it’s telling us that we can just test a single point in a face of the considered arrangement. Unfortunately the arrangement <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{p}}
</script>
</span> doesn’t identify correctly the regions attracting <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, as discovered by the authors of <span class="bibcites">[<a class="bibliocite" name="cite-2" href="#biblio-2"><span class="bib-index">2</span></a>]</span> (see Figure <a class="Reference" href="#fig:IA-wrong">16↑</a> for an example). There it is noted that we need to slightly modify the line arrangement, by considering these sets of lines:
</div>
<ol>
<li>
line through the segments of the Shortest Path Tree of a point <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> (<span class="MathJax_Preview"><script type="math/tex">
\textrm{SPT}\left(p\right)
</script>
</span>);
</li>
<li>
for each reflex vertex, those lines intersecting it that are perpendicular to its incident edges;
</li>
<li>
lines through the edges of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>.
</li>

</ol>
<div class="Unindented">
With this arrangement the algorithm works properly (see <span class="bibcites">[<a class="bibliocite" name="cite-2" href="#biblio-2"><span class="bib-index">2</span></a>]</span> for details). Note that the lines through <span class="MathJax_Preview"><script type="math/tex">
\textrm{SPT}\left(p\right)
</script>
</span> include the sets of lines at the first and third position in the list for the original arrangement, and that the last set of lines is there to discriminate the points that are inside <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>. The authors of <span class="bibcites">[<a class="bibliocite" name="cite-2" href="#biblio-2"><span class="bib-index">2</span></a>]</span> claim the following about the new <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{p}}
</script>
</span>.
</div>
<div class="Lemma"><div class="row">&nbsp;</div>
<p><b>Lemma 4.5. </b><i>Given two points <span class="MathJax_Preview"><script type="math/tex">
b_{1}
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
b_{2}
</script>
</span> and a point <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>, if <span class="MathJax_Preview"><script type="math/tex">
b_{1}
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
b_{2}
</script>
</span> are in the same region of <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{p}}
</script>
</span>, they either both attract <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> or not.
</i></p>
</div>
<div class="Unindented">
We now give the pseudocode of the algorithm.
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--6"></a><div class="float">
<a class="Label" name="Algorithm-2"> </a><div class="algorithm">
<div class="listing">
<pre class="listing"><span class="number-left">1</span>procedure InverseAttractionRegion(P, p)
<span class="number-left">2</span>	Initialize Ap = ∅
<span class="number-left">3</span>	Compute SPT(p)
<span class="number-left">4</span>	for each edge e in SPT(p)
<span class="number-left">5</span>		Add line e to Ap
<span class="number-left">6</span>	end for
<span class="number-left">7</span>	for each reflex vertex r in P do
<span class="number-left">8</span>		Add line rp to Ap
<span class="number-left">9</span>		Add the lines r1 and r2 through r and perpendicular        
<span class="number-left">10</span>			to the edges incident on r to Ap
<span class="number-left">11</span>	end for
<span class="number-left">12</span>	for each edge e in P do
<span class="number-left">13</span>		Add line e to Ap
<span class="number-left">14</span>	end for
<span class="number-left">15</span>	Remove duplicate lines in Ap
<span class="number-left">16</span>	Initialize IA(p) = ∅
<span class="number-left">17</span>	for each face F of Ap do
<span class="number-left">18</span>		Choose an arbitrary point bF of F and compute A(bF)
<span class="number-left">19</span>		if p ∈ A(bF ) then
<span class="number-left">20</span>			Add F to IA(p)
<span class="number-left">21</span>		end if
<span class="number-left">22</span>	end for
<span class="number-left">23</span>	return IA(p), the inverse attraction region of p
<span class="number-left">24</span>end procedure
</pre>
</div>
<div class="caption">
Algorithm 2 <span class="MathJax_Preview"><script type="math/tex">
O(n^{2})
</script>
</span>running-time algorithm for <span class="MathJax_Preview"><script type="math/tex">
IA(p)
</script>
</span> (adapted from <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span>)
</div>

</div>

</div><div class="row">&nbsp;</div>
Complexity Analysis
</div>
<div class="Unindented">
This algorithm uses an attraction region algorithm (<span class="MathJax_Preview"><script type="math/tex">
O\left(n\right)
</script>
</span>/<span class="MathJax_Preview"><script type="math/tex">
O\left(n+h\log^{1+\epsilon}h\right)
</script>
</span>) and it tests, for each attraction region computed, if the given point is in it (<span class="MathJax_Preview"><script type="math/tex">
O\left(n\right)
</script>
</span>). The shortest path tree can be computed in linear time (see <span class="bibcites">[<a class="bibliocite" name="cite-6" href="#biblio-6"><span class="bib-index">6</span></a>]</span>). There are <span class="MathJax_Preview"><script type="math/tex">
O\left(n^{2}\right)
</script>
</span> faces in the arrangement, but walking through them in a breadth-first fashion using the dual graph allows updating the attraction regions quickly, making the overall complexity <span class="MathJax_Preview"><script type="math/tex">
O\left(n^{2}\right)
</script>
</span>.<br/>
The space complexity is <span class="MathJax_Preview"><script type="math/tex">
O\left(n^{2}\right)
</script>
</span>.
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--7"></a><div class="row">&nbsp;</div>Implementation
</div>
<div class="Unindented">
The algorithm was implemented straightforwardly, without any optimization. Thus, it might be a bit slow in some cases (the user needs to wait a second or two to see the result) due to the fact that the faces of the arrangement tend to explode. For quite complex polygons the algorithm might get stuck. The algorithm for the attraction region that was developed earlier has been used here.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-4.3">4.3</a> Algorithm for the Inverse Attraction Region of a Region
</h2>
<div class="Unindented">
To compute the attraction region of a region, it is convenient to consider a modified version of the line arrangement described above. We call the new arrangement <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{R}}
</script>
</span> and we obtain it by considering the lines from each reflex vertex of the input regions through each reflex vertex of the input polygon, thus modifying the set of lines at position 3 of the original arrangement for the attraction region of a point. This arrangement has a property that is similar to that of <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{p}}
</script>
</span> with respect to attracting points in a region.
</div>
<div class="Theorem"><div class="row">&nbsp;</div>
<p><b>Theorem 4.6. </b><i>Given two points <span class="MathJax_Preview"><script type="math/tex">
b_{1}
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
b_{2}
</script>
</span> contained in a face <span class="MathJax_Preview"><script type="math/tex">
F
</script>
</span> of <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{R}}
</script>
</span>, if <span class="MathJax_Preview"><script type="math/tex">
R\cap A\left(b_{1}\right)\neq\varnothing
</script>
</span>, then <span class="MathJax_Preview"><script type="math/tex">
R\cap A\left(b_{2}\right)\neq\varnothing
</script>
</span> .
</i></p>
</div>
<div class="Unindented">
Thanks to this fact we can easily determine te attraction region of <span class="MathJax_Preview"><script type="math/tex">
R
</script>
</span>, by using a point for each face of the arrangement. Since the arrangement for the attraction region of a point was incorrect, it might be that this arrangement is incorrect too, but we didn’t investigate on this.
</div>
<h1 id="a-route" class="Section">
<a class="toc" name="toc-Section-5">5</a> Algorithms for Beacon-Based Routing<a class="Label" name="sec:Algorithms-for-Beacon-Based"> </a>
</h1>
<div class="Unindented">
All the terminology and mathematical statements in this Section are taken from <span class="bibcites">[<a class="bibliocite" name="cite-3" href="#biblio-3"><span class="bib-index">3</span></a>]</span> and <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span>.<br/>
Now that we have seen how to compute the attraction region and the inverse attraction region, we would like to use them in order to perform beacon-based routing. We would also like to find the minimum routing paths each time. In this section we consider first the case where we are given a set of candidate beacons, then the case where we have no beacons except the destination, which we solve with a nearly optimal approximation algorithm.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-5.1">5.1</a> Algorithm for Routing with Candidate Beacons
</h2>
<div class="Unindented">
This algorithm’s main task consists in building a directed graph, that has the candidate beacons, the starting point <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> and the destination <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span> as nodes, and edges of the type <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{\left(u,v\right)}
</script>
</span> if <span class="MathJax_Preview"><script type="math/tex">
u\in A\left(v\right)
</script>
</span>. Once the graph is computed, the routing path is simply a shortest path between the starting point and the destination. We now give the pseudocode of the algorithm.
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--8"></a><div class="float">
<a class="Label" name="Algorithm-3"> </a><div class="algorithm">
<div class="listing">
<pre class="listing"><span class="number-left">1</span>procedure Minimum Beacon Path with Candidates(P,M, s, t)
<span class="number-left">2</span>	Compute a triangulation T of P 
<span class="number-left">3</span>	C = M ∪ s ∪ t 
<span class="number-left">4</span>	Initialize directed graph G = (C, ∅) 
<span class="number-left">5</span>	for each c ∈ C do 
<span class="number-left">6</span>		Compute A(c) 
<span class="number-left">7</span>		for each triangle t ∈ T do 
<span class="number-left">8</span>			Record the subset of t that is attractable to c     
<span class="number-left">9</span>			for each d ∈ M ∩ t do 
<span class="number-left">10</span>				if d ∈ A(c) then 
<span class="number-left">11</span>					Add directed edge dc to G 
<span class="number-left">12</span>				end if 
<span class="number-left">13</span>			end for 
<span class="number-left">14</span>		end for 
<span class="number-left">15</span>	end for 
<span class="number-left">16</span>	Find a shortest path p from s to t in G 
<span class="number-left">17</span>	return the sequence of beacons in p 
<span class="number-left">18</span>end procedure
</pre>
</div>
<div class="caption">
Algorithm 3 <span class="MathJax_Preview"><script type="math/tex">
O(m(n+m))
</script>
</span>running-time algorithm in <br/>
simple polygons (taken from <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span>)
</div>

</div>

</div>

</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--9"><div class="row">&nbsp;</div></a>Complexity Analysis
</div>
<div class="Unindented">
In a simple polygon, the main contribution to the time complexity is given by the for loop. There are <span class="MathJax_Preview"><script type="math/tex">
m+2
</script>
</span> point in <span class="MathJax_Preview"><script type="math/tex">
C
</script>
</span>, and for each of them we spend <span class="MathJax_Preview"><script type="math/tex">
O\left(n\right)
</script>
</span> time computing its attraction region and <span class="MathJax_Preview"><script type="math/tex">
O\left(n+m\right)
</script>
</span> time to determine the edges o include in <span class="MathJax_Preview"><script type="math/tex">
G
</script>
</span>, yelding a total running time of <span class="MathJax_Preview"><script type="math/tex">
O\left(m\left(n+m\right)\right)
</script>
</span>. In a polygon with holes, the triangulation now takes <span class="MathJax_Preview"><script type="math/tex">
O\left(n+h\log^{1+\epsilon}h\right)
</script>
</span> time. As before we spend <span class="MathJax_Preview"><script type="math/tex">
O\left(n\right)
</script>
</span> for each attraction region, but <span class="MathJax_Preview"><script type="math/tex">
O\left(n+m\log h\right)
</script>
</span> to identify the candidate beacons in the triangles. Thus the total running time is <span class="MathJax_Preview"><script type="math/tex">
O\left(mn+m^{2}\log h+h\log^{1+\epsilon}h\right)
</script>
</span>. The space complexity is dominated by the attraction regions and it’s <span class="MathJax_Preview"><script type="math/tex">
O\left(mn\right)
</script>
</span>.
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--10"></a><div class="row">&nbsp;</div>Implementation
</div>
<div class="Unindented">
When it came to implementing the algorithm, it didn’t seem necessary to compute a triangulation and to examine each of the resulting triangles. Indeed, simply checking each ordered pair of beacons is enough, and it doesn’t increase the time complexity. The shortest path is found by using Dijkstra’s shortest path algorithm.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-5.2">5.2</a> Approximation Algorithm
</h2>
<div class="Unindented">
This algorithm starts from a triangulation of a given polygon, then it builds a directed graph in the following way: the nodes are the triangles in the triangulation, and if a triangle <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> intersect the inverse attraction region of another triangle <span class="MathJax_Preview"><script type="math/tex">
a
</script>
</span>, add the directed edge <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{ba}
</script>
</span> to the graph (see <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span> for the computation of the inverse attraction region of a region). To find a sequence of beacons routing <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> to <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span>, find a shortest path between the triangles containing the two points using the graph, and finally take a beacon for each triangle, using the information on the inverse attraction regions. The pseudocode of this algorithm follows.
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--11"></a><div class="float">
<a class="Label" name="Algorithm-4"> </a><div class="algorithm">
<div class="listing">
<pre class="listing"><span class="number-left">1</span>procedure Approximate Minimum Beacon Path(P, s, t)
<span class="number-left">2</span>	Compute a triangulation T of P
<span class="number-left">3</span>	Initialize directed graph G = (T , ∅) 
<span class="number-left">4</span>	for each triangle a ∈ T do 
<span class="number-left">5</span>		Compute IA(a) 
<span class="number-left">6</span>		for each triangle b ∈ T do 
<span class="number-left">7</span>			if b ∩ IA(a) ≠ ∅ then 
<span class="number-left">8</span>				Add directed edge → ba to G 
<span class="number-left">9</span>			end if 
<span class="number-left">10</span>		end for 
<span class="number-left">11</span>	end for 
<span class="number-left">12</span>	Find a shortest path p from s to t in G
<span class="number-left">13</span>	for each triangle a on the shortest path starting from t do 
<span class="number-left">14</span>		Find the corresponding ‘attracting’ point and ‘attracted’ point 
<span class="number-left">15</span>		Link the points together along the shortest path
<span class="number-left">16</span>	end for 
<span class="number-left">17</span>	return the sequence of beacons 
<span class="number-left">18</span>end procedure
</pre>
</div>
<div class="caption">
Algorithm 4 <span class="MathJax_Preview"><script type="math/tex">
O\left(n^{3}\right)
</script>
</span>running-time algorithm (taken from <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span>)
</div>

</div>

</div><div class="row">&nbsp;</div>
Complexity Analysis
</div>
<div class="Unindented">
The running time is determined by the computations of the inverse attraction regions of the triangles. As explained in <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span>, this takes <span class="MathJax_Preview"><script type="math/tex">
O\left(n^{2}\right)
</script>
</span> time. Since we do this for each triangle, the total running time is <span class="MathJax_Preview"><script type="math/tex">
O\left(n^{3}\right)
</script>
</span>.
</div>
<div class="Indented">
<div class="defskip"> </div>
</div>
<div class="Unindented">
We can compare the length of the path obtained with this algorithm with thathof the minimum one thanks to the following lemma.
</div>
<div class="Lemma"><div class="row">&nbsp;</div>
<p><b>Lemma 5.1. </b><i>The shortest path from the triangle containing <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> to that containing <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span> in the graph described above is at most that of a minimum beacon path from <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> to <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span>.
</i></p>
</div>
<div class="Unindented">
Since the beacon path obtained by the algorithm uses two beacons for each triangle, we have an amount of beacons that is at most two times the necessary beacons. If we iteratively compute the inverse attraction region for each triangle ( <span class="MathJax_Preview"><script type="math/tex">
\textrm{IA}\left(...\textrm{IA}\left(a\right)\right)
</script>
</span> ), we obtain a beacon path that has at most <span class="MathJax_Preview"><script type="math/tex">
k+1
</script>
</span> beacons every <span class="MathJax_Preview"><script type="math/tex">
k
</script>
</span> beacons in the optimal path. This gives us a polynomial-time approximation of the minimum beacon path (see <span class="bibcites">[<a class="bibliocite" name="cite-3" href="#biblio-3"><span class="bib-index">3</span></a>, <a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span>).
</div>
<h1 id="a-applet" class="Section">
<a class="toc" name="toc-Section-6">6</a> Applet<a class="Label" name="sec:Applet"> </a>
</h1>
<div class="Unindented">
An applet was developed to illustrate interactively the main concepts of this page. It can be reached by clicking on the button below. Instructions are included in the destination page.
</div>

		<div class="row">&nbsp;</div>
		<div class="row">&nbsp;</div>
		<div class="centera">
			<a id="draw" href="html/applet/index.html" class="btn-lg btn-danger">Applet</a>
		</div>

<div class="Indented">
<h1 id="a-ref" class="biblio">
References
</h1>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-1"><span class="bib-index">1</span></a>] </span> <span class="bib-authors">B. Chazelle, H. Edelsbrunner, M. Grigni, L. Guibas, J. Hershberger, M. Sharir, J. Snoeyink</span>. <span class="bib-title">Ray shooting in polygons using geodesic triangulations</span>. <i><span class="bib-journal">Algorithmica</span></i>, <span class="bib-volume">12</span>(<span class="bib-number">1</span>):<span class="bib-pages">54—68</span>, <span class="bib-year">1994</span>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-2"><span class="bib-index">2</span></a>] </span> <span class="bib-authors">Bahram Kouhestani, David Rappaport, Kai Salomaa</span>. <span class="bib-title">On the Inverse Beacon Attraction Region of a Point</span>.  <i><span class="bib-booktitle">CCCG</span></i>, <span class="bib-year">2015</span>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-3"><span class="bib-index">3</span></a>] </span> <span class="bib-authors">Michael Biro, Justin Iwerks, Irina Kostitsyna, Joseph S. B. Mitchell</span>. <span class="bib-title">Algorithms and Data Structures: 13th International Symposium, WADS 2013, London, ON, Canada, August 12-14, 2013. Proceedings</span>. <span class="bib-publisher">Springer Berlin Heidelberg</span>, <span class="bib-year">2013</span>. URL <a href="http://dx.doi.org/10.1007/978-3-642-40104-6_14"><span class="bib-url">http://dx.doi.org/10.1007/978-3-642-40104-6_14</span></a>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-4"><span class="bib-index">4</span></a>] </span> <span class="bib-authors">Michael Biro</span>. <span class="bib-title">Beacon-based routing and guarding</span>. <span class="bib-year">2013</span>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-5"><span class="bib-index">5</span></a>] </span> <span class="bib-authors">Bernard Chazelle</span>. <span class="bib-title">Triangulating a Simple Polygon in Linear Time</span>. <i><span class="bib-journal">Discrete Comput. Geom.</span></i>, <span class="bib-volume">6</span>(<span class="bib-number">5</span>):<span class="bib-pages">485—524</span>, <span class="bib-year">1991</span>. URL <a href="http://dx.doi.org/10.1007/BF02574703"><span class="bib-url">http://dx.doi.org/10.1007/BF02574703</span></a>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-6"><span class="bib-index">6</span></a>] </span> <span class="bib-authors">L Guibas, J Hershberger, D Leven, M Sharir, R Tarjan</span>. <span class="bib-title">Linear Time Algorithms for Visibility and Shortest Path Problems Inside Simple Polygons</span>.  <i><span class="bib-booktitle">Proceedings of the Second Annual Symposium on Computational Geometry</span></i>:<span class="bib-pages">1—13</span>, <span class="bib-year">1986</span>. URL <a href="http://doi.acm.org/10.1145/10515.10516"><span class="bib-url">http://doi.acm.org/10.1145/10515.10516</span></a>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-7"><span class="bib-index">7</span></a>] </span> <span class="bib-authors">N. Mouawad</span>. <span class="bib-title">Minimal obscuring sets: the parallel view case</span>.  <i><span class="bib-booktitle">Proc. 2nd Canad. Conf. Comput. Geom.</span></i>:<span class="bib-pages">232—235</span>, <span class="bib-year">1990</span>.
</p>

</div>

						<div class="row">&nbsp;</div>
						<div class="row">&nbsp;</div>
</div>
						</div>
					</div>
				</div>
				<div id="game" class="container-fluid tab-pane fade">
					<div class="row">
						<div class="col-md-1"></div>
						<div class="col-md-10">
							<h1>Instructions</h1>
							<p>Welcome to the awesome <i>Can you Route it?</i> !!! 
								Are you ready to solve all the levels and not get stuck in the journey? Let’s see!
							</p>
							<h2>How can you play?</h2>
							<p>After selecting a level, you will see the polygon and the points you have to route between (origin in red and destination in green).
								<br/> You will also see a combination of beacons, in dark color, proposed to route between the origin and the destination. But these beacons have been chosen by a >malicious algorithm, which is a bit silly. Can you reduce the number of beacons in the path?
								<br/><br/><i>Can you do better?</i><br/><br/>
								If you press <b>Start</b>, you will start the level. Then you can introduce the beacons, in order, of your path. They will be shown in blue. Try to use as less as possible!
								Once you have finished your path, press <b>Ready</b>. First, you will see your path, beacon by beacon with their attraction regions. Then you will receive your score!
								<ul>
									<li><b>You lose! Not routed!</b><br/>
  										In case the path you have introduced is not even a path!
									</li>
									<li><b>You lose! Excess!</b><br/>
  										You have introduced too many beacons!
									</li>
									<li><b>Good!</b><br/>
  										Well done, you have beaten the evil algorithm! But not by far…
									</li>
									<li><b>Very Good!</b><br/>
  										Congratulations! You have managed to do it great! You are top at this…
									</li>
									<li><b>Excellent!</b><br/>
  										No words. You have done it even better than the designers, Einstein.
									</li>
								</ul>
							</p>
							<p>If you press <b>Hint</b>, then you can select a beacon and see its attraction region for 5 seconds. But be careful, you’ll have a limited amount of hints!</p>
							<h2>Levels</h2>
							<p>You will start an incredible journey of 4 levels of difficulty!</p>
							<ol>
								<li><b>Easy</b>: 
										You have introduced too many beacons!
								</li>
								<li><b>Medium</b>: 
										Well done, you have beaten the evil algorithm! But not by far…
								</li>
								<li><b>Hard</b>: 
										Congratulations! You have managed to do it great! You are top at this…
								</li>
								<li><b>Implossible maze</b>: 
										No words. You have done it even better than the designers, Einstein.
								</li>
							</ol>
							<p>Once you have succeeded in a level, you will unlock the next one! Then you can move between the unlocked levels by using <b>PREV</b> and <b>NEXT</b>.
								<br/><br/><i>Are you prepared to complete this odyssey?</i>
							</p>
							<h2>Other Information</h2>
							<p>You can turn on and off the music by clicking on the <b>Sound button</b>.
								Press Back to exit the game and return to this page.
							</p>
						</div>
						<div class="col-md-1"></div>
					</div>
					<div class="row">

									<div class="row">&nbsp;</div>
									<div class="row">&nbsp;</div>
									<div class="centera">
										<a href="html/game/index.html" class="btn-lg btn-danger">PLAY!</a>
									</div>
									<div class="row">&nbsp;</div>
									<div class="row">&nbsp;</div>

							</div>
						<div class="row">&nbsp;</div>
						<div class="row">&nbsp;</div>
				</div>
				<div id="ack" class="container-fluid tab-pane fade">
					<div class="row">
						<div class="col-md-1"></div>
						<div class="col-md-10">
							<div class="row">&nbsp;</div>
							<div class="row">&nbsp;</div>
							<p>In this project, David focused more on coverage, while Andrea worked on routing. David treated routing too, but we addressed the topic using complementary approaches.</p>
							<p>The videogame is the result of team work. David designed the polygons for the levels, provided the default beacons and the lower bounds on beacons for each level. Andrea took care of the programming part.</p>
							<h3>Credits</h3>
							<p>
								Thanks to Stefan Langerman, our Computational Geometry teacher from Algorithms Research Group in the Université Libre de Bruxelles, for his helpful advises throughout the conception and implementation of this project. Additional thanks to him from Andrea, for outlining the Shortest Path Tree algorithm.
								Thanks also to Irina Kostitsyna, for answering so quickly to our doubts and confirm our thoughts.
							</p>
							<h4>Videogame</h4>
							<p>Title artwork by <a href="http://textcraft.net/">Textcraft</a>.</p>
				<p>Game font: Charybdis by <a href="http://www.tepidmonkey.net/">Tepid Monkey Fonts</a>.</p>
				<p>1st and 3rd level music: Investigations Kevin MacLeod (<a href="incompetech.com">incompetech.com</a>) <br/>
					Licensed under Creative Commons: By Attribution 3.0 License <br/>
					<a href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</a>.</p>
				<p>2nd and 4th level music: Sneaky Adventure Kevin MacLeod (<a href="incompetech.com">incompetech.com</a>) <br/>
					Licensed under Creative Commons: By Attribution 3.0 License <br/>
					<a href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</a>.</p>
				<p>Routing music: Good Starts Jungle Punks.</p>
				<p>Win sound: Ta Da Sound (<a href="soundbible.com">soundbible.com</a>) <br/>
					Licensed under Creative Commons: By Attribution 3.0 License <br/>
					<a href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</a>.</p>
				<p>Lose sound: Sad Trombone Sound (<a href="soundbible.com">soundbible.com</a>) <br/>
					Licensed under Creative Commons: By Attribution 3.0 License <br/>
					<a href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</a>.</p>
							<div class="row">&nbsp;</div>
							<div class="row">&nbsp;</div>
						</div>
						<div class="col-md-1"></div>
					</div>
				</div>
			</div>
		</div>
		<footer>
					<div class="row">&nbsp;</div>
				  <p>Theme: Lumen by <a href="https://bootswatch.com/">Bootswach</a>.</p>

		</footer>
	</body>
</html>