<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="generator" content="http://www.nongnu.org/elyxer/"/>
<meta name="create-date" content="2016-02-29"/>
<link rel="stylesheet" href="http://elyxer.nongnu.org/lyx.css" type="text/css" media="all"/>
<title>Converted document</title>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
<div id="globalWrapper">
<script type="math/tex">
\newcommand{\lyxlock}{}
</script>
<noscript>
<div class="warning">
Warning: <a href="http://www.mathjax.org/">MathJax</a> requires JavaScript to correctly process the mathematics on this page. Please enable JavaScript on your browser.
</div><hr/>
</noscript>
<h1 class="Section">
<a class="toc" name="toc-Section-1">1</a> Introduction
</h1>
<div class="Unindented">
In this page we will look at how beacons interact with objects placed in a polygon. We will define relevant regions in a polygon, with respect to one or more beacons and interacting objects, namely the Attraction Region <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> of a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> and the Inverse Attraction Region <span class="MathJax_Preview"><script type="math/tex">
IA\left(p\right)
</script>
</span> of a point <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>, and we will look at their key properties. We will also see how to compute those regions, then we will give algorithms that exploit the knowledge of them to route an object starting at a position <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> until a final point <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span>.<br/>
The content of this page is a re-elaboration from <span class="bibcites">[<a class="bibliocite" name="cite-2" href="#biblio-2"><span class="bib-index">2</span></a>]</span> and <span class="bibcites">[<a class="bibliocite" name="cite-1" href="#biblio-1"><span class="bib-index">1</span></a>]</span>.<br/>
In Section <a class="Reference" href="#sec:Setting-and-Terminology">2↓</a> we describe the generic setting that we consider throughout the page and give basic definitions; in Section <a class="Reference" href="#sec:The-Attraction-Region">3↓</a> we define the Attraction Region of a beacon, give its properties and algorithms to compute it; in Section <a class="Reference" href="#sec:The-Inverse-Attraction">4↓</a> we discuss the Inverse Attraction Region of a point, following an outline that is similar to the previous section; Section <a class="Reference" href="#sec:Algorithms-for-Beacon-Based">5↓</a> contains two algorithm that route an object from a point <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> to a point <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span>. One requires a set of candidate intermediate beacons, the other is a polynomial-time approximation of the optimal route.
</div>
<h1 class="Section">
<a class="toc" name="toc-Section-2">2</a> Setting and Terminology<a class="Label" name="sec:Setting-and-Terminology"> </a>
</h1>
<div class="Unindented">
We consider a <i>polygon</i> <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, whose boundary edges are oriented counterclockwise (the edges of a hole are instead oriented clockwise). A <i>beacon</i> <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> is a point in the interior of <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> that can be activated to exercise a ’magnetic pull’ on an object initially placed at a point <span class="MathJax_Preview"><script type="math/tex">
p\epsilon P
</script>
</span>. <div class="float">
<a class="Label" name="Figure-1"> </a><div class="figure">
<img class="embedded" src="1.png" alt="figure 1.png" style="width: 423px; max-width: 847px; height: 337px; max-height: 674px;"/>
<div class="caption">
Figure 1 A beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> excercises a ’magnetic pull’ on a point <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>.
</div>

</div>

</div>
<br/>
When <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> is active, the object decreases its Euclidean distance from <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> greedily, following a straight line towards b until it reaches either <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> or<span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span>. In the second case, it slides along <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> provided that its distance from <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> decreases monotonically. When the object is no more constrained by <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span>, it moves again in a straight line. Thus, a generic route from a point <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> to a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> alternates between these described modes.<div class="float">
<a class="Label" name="Figure-2"> </a><div class="figure">
<img class="embedded" src="2.png" alt="figure 2.png" style="width: 450px; max-width: 1125px; height: 526px; max-height: 1317px;"/>
<div class="caption">
Figure 2 An object starting at <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> moves unconstrained <br/>
unless it meets <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span>, then it slides along it.
</div>

</div>

</div>
<br/>
If the object reaches a point in which the distance from <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> cannot decrease that is different from<span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, we say the object is <i>stuck</i>. The reached point is called a <i>dead point</i> on <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> for beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>. The set of dead points for <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> is referred to as <span class="MathJax_Preview"><script type="math/tex">
D\left(b\right)
</script>
</span> If an object starting at <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is able to reach <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, we say that <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> <i>attracts</i> <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> (<span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> <i>is attracted to</i> <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>).<br/>
When routing an object from a starting point <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> to a destination <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span>, we use a set <span class="MathJax_Preview"><script type="math/tex">
M
</script>
</span> of beacon points, which we activate in sequence: only one beacon at a time is active, and it remains active until it is reached by the object. At that point the next beacon is activated and the old one is simultaneously deactivated. We say that <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span> are <i>routed</i> if we can find a set <span class="MathJax_Preview"><script type="math/tex">
M'
</script>
</span>of beacon points that, if activated in the right sequence, can route an object from <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> to <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span>.i<div class="float">
<a class="Label" name="Figure-3"> </a><div class="figure">
<img class="embedded" src="5.png" alt="figure 5.png" style="width: 947px; max-width: 1895px; height: 560px; max-height: 1121px;"/>
<div class="caption">
Figure 3 <span class="MathJax_Preview"><script type="math/tex">
s
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
t
</script>
</span> are routed.
</div>

</div>

</div>
<br/>
Given a dead point <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span> and a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, we call <span class="MathJax_Preview"><script type="math/tex">
DR_{b}\left(d\right)
</script>
</span> the <i>dead region</i> of <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span> with respect to <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, which we define as the set of points <span class="MathJax_Preview"><script type="math/tex">
p\epsilon P
</script>
</span> that will eventually get stuck at <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span> under the influence of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>. There are two types of dead points: vertex dead points and edge dead points.<div class="float">
<a class="Label" name="Figure-4"> </a><div class="multifigure">
<span class="float">
<div class="figure">
<img class="embedded" src="6.png" alt="figure 6.png" style="width: 404px; max-width: 1037px; height: 436px; max-height: 1119px;"/>
<div class="caption">
(a) The dead region of <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span> is shown in red.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="3.png" alt="figure 3.png" style="width: 420px; max-width: 1077px; height: 441px; max-height: 1133px;"/>
<div class="caption">
(b) <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span> is a vertex dead point.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="4.png" alt="figure 4.png" style="width: 474px; max-width: 1185px; height: 436px; max-height: 1091px;"/>
<div class="caption">
(c) <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span> is an edge dead point.
</div>

</div>

</span>
<div class="caption">
Figure 4 Types of dead points.
</div>

</div>

</div>
<br/>
We can distinguish points belonging to <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> as <i>odd boundary points </i>or <i>even boundary points, </i>depending on whether an object placed at them moves unconstrained or along <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> under the influence of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>. It can be easily seen that all dead points are even boundary points.
</div>
<h1 class="Section">
<a class="toc" name="toc-Section-3">3</a> The Attraction Region<a class="Label" name="sec:The-Attraction-Region"> </a>
</h1>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.1">3.1</a> Definition
</h2>
<div class="Unindented">
The Attraction Region of a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> is defined as follows:
</div>
<div class="Definition">
The Attraction Region <span class="MathJax_Preview"><script type="math/tex">
A(b)
</script>
</span> of a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> is the set of points <span class="MathJax_Preview"><script type="math/tex">
p\epsilon P
</script>
</span> that are attracted to b.
</div>
<div class="Definition">
<div class="float">
<a class="Label" name="Figure-5"> </a><div class="figure">
<img class="embedded" src="7.png" alt="figure 7.png" style="width: 662px; max-width: 1657px; height: 613px; max-height: 1533px;"/>
<div class="caption">
Figure 5 The attraction region of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> is shown in green.
</div>

</div>

</div>

</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.2">3.2</a> Properties
</h2>
<div class="Unindented">
We would like to obtain insights on how to easily define the boundaries of Attraction Regions, so we explore some of their properties, but also the properties of other related entities.<br/>
Let’s start by asking ourselves how many dead points are there, given a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>. The following theorems give us tight bounds, distinguishing between polygons without or with holes.
</div>
<div class="Theorem">
Given a simple polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> with <span class="MathJax_Preview"><script type="math/tex">
n
</script>
</span> vertices, we have <span class="MathJax_Preview"><script type="math/tex">
0\leq\left|D(b)\right|\leq n-3
</script>
</span>.
</div>
<div class="Proof">
If <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> is convex it has no dead points, so the lower bound can be easily observed. For the upper bound, consider a beacon <span class="MathJax_Preview"><script type="math/tex">
b\epsilon P
</script>
</span>. It can be easily seen that at least <span class="MathJax_Preview"><script type="math/tex">
3
</script>
</span> edges of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> are visible to <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, so any ray starting from <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> that crosses these edges would cross them first. Thus we would have an odd number of crossings for each of these three edges, that consequently cannot contain dead points. Finally, an edge contains at most <span class="MathJax_Preview"><script type="math/tex">
1
</script>
</span> dead point, so the given upper bound holds.
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-6"> </a><div class="multifigure">
<span class="float">
<div class="figure">
<img class="embedded" src="8.png" alt="figure 8.png" style="width: 390px; max-width: 781px; height: 799px; max-height: 1598px;"/>
<div class="caption">
(a) <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> has <span class="MathJax_Preview"><script type="math/tex">
7-3=n-3=4
</script>
</span> dead points.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="9.png" alt="figure 9.png" style="width: 400px; max-width: 817px; height: 792px; max-height: 1618px;"/>
<div class="caption">
(b) <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> has <span class="MathJax_Preview"><script type="math/tex">
13-2-3=n-h-3=8
</script>
</span> dead points.
</div>

</div>

</span>
<div class="caption">
Figure 6 Polygons showing that the upper bounds for dead points are reachable.
</div>

</div>

</div>

</div>
<div class="Theorem">
Given a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> with <span class="MathJax_Preview"><script type="math/tex">
n
</script>
</span> vertices and <span class="MathJax_Preview"><script type="math/tex">
h
</script>
</span> holes, we have <span class="MathJax_Preview"><script type="math/tex">
0\leq\left|D(b)\right|\leq n-h-3
</script>
</span>.
</div>
<div class="Proof">
This time we can observe the lower bound by taking a convex polygon with the holes being only triangles, oriented so that they don’t have any dead points. For the upper bound, first imagine to remove the holes from <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> and consider the resulting simple polygon <span class="MathJax_Preview"><script type="math/tex">
P'
</script>
</span>. If <span class="MathJax_Preview"><script type="math/tex">
n_{i}
</script>
</span> is the number of vertices of the <span class="MathJax_Preview"><script type="math/tex">
i
</script>
</span>th hole, then <span class="MathJax_Preview"><script type="math/tex">
P'
</script>
</span> has <span class="MathJax_Preview"><script type="math/tex">
n-\sum_{i}n_{i}
</script>
</span> vertices. <span class="MathJax_Preview"><script type="math/tex">
b\epsilon P
</script>
</span> so <span class="MathJax_Preview"><script type="math/tex">
P'
</script>
</span> as at most <span class="MathJax_Preview"><script type="math/tex">
n-\sum_{i}n_{i}-3
</script>
</span>. To be continued with figures
</div>
<div class="Unindented">
Thanks to these theorems, we can limit the number of dead points for a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, thus we can also limit the number of its dead regions. We take a step further towards our goal by stating that the dead regions of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> form a partition of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>.
</div>
<div class="Theorem">
The dead regions of a beacon<span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> in a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, along with <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> partition <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>.<a class="Label" name="thm:The-dead-regions"> </a>
</div>
<div class="Proof">
First of all, an object starting at a point in <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> will either reach <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> or a dead point <span class="MathJax_Preview"><script type="math/tex">
d
</script>
</span>, thus fulfilling the requirement that the regions taken togheter yeld <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>. It remains to show that these regions don’t overlap. In a situation as that of Figure, our definitions are not enough precise to decide along which edge incident to a reflex vertex <span class="MathJax_Preview"><script type="math/tex">
v
</script>
</span> an object at <span class="MathJax_Preview"><script type="math/tex">
v
</script>
</span> will slide. The problem is eliminated by adopting the convention that objects at <span class="MathJax_Preview"><script type="math/tex">
v
</script>
</span> go always left. We have ensured that an object will follow a unique path under the influence of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>: <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> is subdivided into disjoint regions. From what we said, each point is located in a region, so the proof is complete.
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-7"> </a><div class="multifigure">
<span class="float">
<div class="figure">
<img class="embedded" src="10.png" alt="figure 10.png" style="width: 334px; max-width: 669px; height: 510px; max-height: 1021px;"/>
<div class="caption">
(a) We arbitrarily decide that <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> goes always left.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="11.png" alt="figure 11.png" style="width: 565px; max-width: 1529px; height: 468px; max-height: 1265px;"/>
<div class="caption">
(b) An example partition, induced by <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>.<br/>
The attraction region is in green, the dead <br/>
regions with their respective dead points are in red.
</div>

</div>

</span>
<div class="caption">
Figure 7 Visualization of the arguments of Theorem <a class="Reference" href="#thm:The-dead-regions">3.2↑</a>.
</div>

</div>

</div>
<br/>
This result gives us an interesting hint, because it tells us that to identify <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> we can try to determine the edges of the partition induced by <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>. How to do this? It turns out that we need to use a particular kind of vertices in <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, called split vertices. We elaborate on them in the next subsection.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.3">3.3</a> Split Vertices
</h2>
<div class="Unindented">
We start by defining <i>cut vertices</i>, which are a particular case of reflex vertices.
</div>
<div class="Definition">
Given a reflex vertex <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>, we say that <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is a cut vertex if the ray <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp}
</script>
</span> with its origin translated to <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> cuts the interior of <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> starting immediately from <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>.
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-8"> </a><div class="figure">
<img class="embedded" src="12.png" alt="figure 12.png" style="width: 378px; max-width: 757px; height: 324px; max-height: 649px;"/>
<div class="caption">
Figure 8 <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is a cut vertex.
</div>

</div>

</div>
<br/>
How do we recognize a cut vertex? We can simply compute two dot products, as the next proposition precises.
</div>
<div class="Proposition">
Given a reflex vertex <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span>, we say it is a cut vertex if:
</div>
<div class="Proposition">
1. <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\times\overrightarrow{p_{i}p_{i+1}}<0
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\times\overrightarrow{p_{i-1}p_{i}}<0
</script>
</span> (Class I)
</div>
<div class="Proposition">
2. <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\times\overrightarrow{p_{i}p_{i+1}}>0
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\times\overrightarrow{p_{i-1}p_{i}}<0
</script>
</span> (Class II)
</div>
<div class="Proposition">
3. <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\times\overrightarrow{p_{i}p_{i+1}}<0
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\times\overrightarrow{p_{i-1}p_{i}}>0
</script>
</span> (Class III)
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-9"> </a><div class="multifigure">
<span class="float">
<div class="figure">
<img class="embedded" src="13.png" alt="figure 13.png" style="width: 266px; max-width: 533px; height: 335px; max-height: 671px;"/>
<div class="caption">
(a) <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is Class I cut vertex.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="14.png" alt="figure 14.png" style="width: 383px; max-width: 723px; height: 331px; max-height: 625px;"/>
<div class="caption">
(b) <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is Class II cut vertex.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="15.png" alt="figure 15.png" style="width: 358px; max-width: 703px; height: 328px; max-height: 645px;"/>
<div class="caption">
(c) <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is Class III cut vertex.
</div>

</div>

</span>
<div class="caption">
Figure 9 Types of cut vertices.
</div>

</div>

</div>
<br/>
Now, a split vertex is just a particular case of cut vertex. We can identify it just by computing some additional dot products:
</div>
<div class="Proposition">
Given a cut vertex <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span>, we say it is a split vertex if and only if:
</div>
<div class="Proposition">
1. It is a class I cut vertex and <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\cdot\overrightarrow{p_{i}p_{i+1}}<0
</script>
</span>, <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\cdot\overrightarrow{p_{i-1}p_{i}}>0
</script>
</span>b
</div>
<div class="Proposition">
2. It is a class II cut vertex and <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\cdot\overrightarrow{p_{i-1}p_{i}}>0
</script>
</span>
</div>
<div class="Proposition">
3. It is a class III cut vertex and <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}\cdot\overrightarrow{p_{i}p_{i+1}}<0
</script>
</span>
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-10"> </a><div class="multifigure">
<span class="float">
<div class="figure">
<img class="embedded" src="13.png" alt="figure 13.png" style="width: 266px; max-width: 533px; height: 335px; max-height: 671px;"/>
<div class="caption">
(a) <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is a Class I cut vertex and a split vertex.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="16.png" alt="figure 16.png" style="width: 294px; max-width: 627px; height: 336px; max-height: 717px;"/>
<div class="caption">
(b) <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is a Class II cut vertex and a split vertex.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="17.png" alt="figure 17.png" style="width: 324px; max-width: 649px; height: 331px; max-height: 663px;"/>
<div class="caption">
(c) <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is a Class III cut vertex and a split vertex.
</div>

</div>

</span>
<div class="caption">
Figure 10 Types of split vertices.
</div>

</div>

</div>
<br/>
Given a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> and a split vertex <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> with respect to <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, we can identify the corresponding <i>split edge</i> by considering the first intersection of the ray <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}
</script>
</span> starting at <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> with <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span>, which we call the <i>ray vertex</i>. Split edges play a central role in the partition induced by a beacon: they are the boundary between two adjacent regions (although in polygons wih holes they might be entirely contained in a region).<br/>
<div class="float">
<a class="Label" name="Figure-11"> </a><div class="figure">
<img class="embedded" src="19.png" alt="figure 19.png" style="width: 450px; max-width: 901px; height: 418px; max-height: 837px;"/>
<div class="caption">
Figure 11 <span class="MathJax_Preview"><script type="math/tex">
v
</script>
</span> is the ray vertex correspoinding to <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span>. <span class="MathJax_Preview"><script type="math/tex">
\overline{pv}
</script>
</span> is a split edge.
</div>

</div>

</div>

</div>
<div class="Theorem">
Given a simple polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> and one of its split edges <span class="MathJax_Preview"><script type="math/tex">
e=\overline{p_{i}q_{i}}
</script>
</span> with respect to a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> (<span class="MathJax_Preview"><script type="math/tex">
q_{i}
</script>
</span> is the ray vertex), <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> represents the boundary between two dead regions or between <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> and a dead region. This might not be the case for a polygon with holes, where <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> might be entirely contained in the interior of <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> or a dead region, but it can intersect at most one region.<a class="Label" name="thm:Given-a-simple"> </a>
</div>
<div class="Proof">
Consider first the case where <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> is simple. Then <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> represents a diagonal of <span class="MathJax_Preview"><script type="math/tex">
P+q_{i}
</script>
</span>. This polygon is divided into two parts, that we call <span class="MathJax_Preview"><script type="math/tex">
P_{L}
</script>
</span>and <span class="MathJax_Preview"><script type="math/tex">
P_{R}
</script>
</span>. We need to figure out how an object could possibly cross <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> under the attracion of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> , and show that any possible case is infeasible. Objects placed on <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> will eventually reach <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> and slide left, because of our convention. What’s more, an object moving unconstrained under the influence of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> could never cross <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> and switch between <span class="MathJax_Preview"><script type="math/tex">
P_{L}
</script>
</span>and <span class="MathJax_Preview"><script type="math/tex">
P_{R}
</script>
</span>, because e is parallel to the ray <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{bp_{i}}
</script>
</span>. It remains to handle the case where the objects starts sliding along <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span>. But the crossing of <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> cannot happen here, because of the following argument. <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> is a split vertex; this means that objects sliding along the edges adjacent to <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> move away from it, thus if they are on differents sides of <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span>, they are in different regions. <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> is on the the boundary of at most two regions, because the points on a ray move unconstrained until they all meet <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> at hte same location, meaning that they will end up in the same point. Thus ray on different sides of <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> are in different regions, that have <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> as boundary.<br/>
If <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> has holes, some points on different sides of <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> could slide around a hole and end up in the same location, causing <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span> to be contained in a region.
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-12"> </a><div class="multifigure">
<span class="float">
<div class="figure">
<img class="embedded" src="20.png" alt="figure 20.png" style="width: 540px; max-width: 1081px; height: 512px; max-height: 1025px;"/>
<div class="caption">
(a) An object starting at <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> and moving unconstrained can never cross <span class="MathJax_Preview"><script type="math/tex">
e
</script>
</span>.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="21.png" alt="figure 21.png" style="width: 470px; max-width: 941px; height: 516px; max-height: 1033px;"/>
<div class="caption">
(b) An object starting at <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> and reaching <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span> will always move away from <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span>.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="22.png" alt="figure 22.png" style="width: 560px; max-width: 1121px; height: 566px; max-height: 1133px;"/>
<div class="caption">
(c) Objects on the same ray cast from <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> end in the same point.
</div>

</div>

</span>
<div class="caption">
Figure 12 Visualization of the arguments of Theorem <a class="Reference" href="#thm:Given-a-simple">3.3↑</a>
</div>

</div>

</div>
<br/>
We are now close to a correct description of a partition induced by a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> on a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>. In addition to split edges, we need to say something about the edges of <span class="MathJax_Preview"><script type="math/tex">
\partial P
</script>
</span>, and establish which kind of edges can form the partition.
</div>
<div class="Theorem">
A boundary edge of a region in the partition of a simple polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> induced by a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> can be either:
</div>
<div class="Theorem">
1. An edge of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> that has not been divided by a split edge
</div>
<div class="Theorem">
2. A split edge
</div>
<div class="Theorem">
3. An edge of the form <span class="MathJax_Preview"><script type="math/tex">
\left(p_{k},q_{i}\right)
</script>
</span>, <span class="MathJax_Preview"><script type="math/tex">
\left(q_{i},p_{l}\right)
</script>
</span> or <span class="MathJax_Preview"><script type="math/tex">
\left(q_{i},q_{j}\right)
</script>
</span>, with <span class="MathJax_Preview"><script type="math/tex">
q_{i}
</script>
</span>and <span class="MathJax_Preview"><script type="math/tex">
q_{j}
</script>
</span> adjacent ray vertices lying on the edge <span class="MathJax_Preview"><script type="math/tex">
e=\left(p_{k},p_{l}\right)
</script>
</span>.<a class="Label" name="thm:3.-An-edge"> </a>
</div>
<div class="Proof">
For simple polygons, let us start by noticing that all the edges are on the boundary of one or more regions, because all the points in <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> belong to the partition. We have already talked about split edges. We can easily notice that the edges descibed at the third element of our list are components of an edge of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, that have been split by one or more ray vertices, in such a way that they are on the boundary of only one region, while the original edge <span class="MathJax_Preview"><script type="math/tex">
\left(p_{k},p_{l}\right)
</script>
</span>is on the boundary of a different region per different component. We are not done yet; we need to show that no other type of edge can be on the boundary of a region. Let us imagine that there exists a component <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> on the boundary of a region that isn’t of any type mentioned so far. First, it cannot be that any part of <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> isn’t parallel to a ray casted from the beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, that intesects <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span>, because otherwise objects on some points of the ray would move unconstrained until they would cross <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span>, thus sharing the region of the points on the other side of <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> . We also have to take into account that <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> would intersect <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> at two points, that we may call <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
s_{2}
</script>
</span>. Assume that <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span> is the closer to <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> between the two. Where is <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span>? It turns out that it must be a vertex of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>. Points on <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> will reach <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span>. If <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span> was in the interior of an edge of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, we would have crossings of <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span>: in case <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span> was a dead point, objects from either side would get stuck at <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span>, in case not, objects would slide along the edge containing <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span>, ending again at the same dead point. Now if we think about which of the elements of our list has the characteristics of <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> (acting as a separator of the points on different sides), we see that it is exactly a split edge, with <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span> as the split vertex.<br/>
In a polygon with holes, it might happen that some split edges or components of divided edges are not on the boundary of a region.
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-13"> </a><div class="multifigure">
<span class="float">
<div class="figure">
<img class="embedded" src="23.png" alt="figure 23.png" style="width: 320px; max-width: 256px; height: 513px; max-height: 411px;"/>
<div class="caption">
(a) If <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> wasn’t entirely parallel to <br/>
a ray cast from <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> that crosses it, <br/>
some points would cross <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span>.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="24.png" alt="figure 24.png" style="width: 315px; max-width: 685px; height: 410px; max-height: 893px;"/>
<div class="caption">
(b) <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span> cannot be an edge dead point,<br/>
 because otherwise points on<br/>
different sides of <span class="MathJax_Preview"><script type="math/tex">
c
</script>
</span> would reach it.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<img class="embedded" src="25.png" alt="figure 25.png" style="width: auto; max-width: 585px; height: 10.3cm; max-height: 1049px;"/>
<div class="caption">
(c) <span class="MathJax_Preview"><script type="math/tex">
s_{1}
</script>
</span> cannot be on an edge in<br/>
general, because otherwise <br/>
some points would cross it and <br/>
go into the adjacent region.
</div>

</div>

</span>
<div class="caption">
Figure 13 Visualization of the arguments of Theorem <a class="Reference" href="#thm:3.-An-edge">3.3↑</a>
</div>

</div>

</div>
<br/>
Now we can define a concrete strategy for obtaining the attraction region algorithmically! Given a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> and a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, first we need to find the split vertices of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> with respect to <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, then compute the corresponding ray vertices to obtain the split edges and the components of the divided edges of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>. In case of a polygon with holes this is not enough; we also need to discard the edges that we meet twice when walking along the boundaries of the regions. By doing this we will obtain a set of regions, namely the dead regions, each containing a different dead point, and the atracion region.<br/>
There are a few more properties of the attraction region of a beacon that are worth mentioning; we give them in the next section.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.4">3.4</a> Additional Properties
</h2>
<div class="Proposition">
If <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> is a beacon, <span class="MathJax_Preview"><script type="math/tex">
b\epsilon A\left(b\right)
</script>
</span>. Moreover, if <span class="MathJax_Preview"><script type="math/tex">
V\left(b\right)
</script>
</span> is the visibility polygon of <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, we have that <span class="MathJax_Preview"><script type="math/tex">
V\left(b\right)\subseteq A\left(b\right)
</script>
</span> (equality might hold as well).
</div>
<div class="Theorem">
Given a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> is connected.
</div>
<div class="Unindented">
a
</div>
<div class="Theorem">
Given a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> is convex with respect to <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, if <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> is simple (not necessarily if it has holes).
</div>
<div class="Unindented">
a
</div>
<div class="Corollary">
Given a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>, <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span> has no holes, if <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> is simple (not necessarily if it has holes).
</div>
<div class="Theorem">
The partition of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> induced by a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span> has boundary complexity <span class="MathJax_Preview"><script type="math/tex">
O\left(n\right)
</script>
</span>, as well as <span class="MathJax_Preview"><script type="math/tex">
A\left(b\right)
</script>
</span>. There exist cases with also<span class="MathJax_Preview"><script type="math/tex">
\Omega\left(n\right)
</script>
</span>.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-3.5">3.5</a> Algorithms for the Attraction Region
</h2>
<div class="Unindented">
In this subsection we review the existing algorithms for computing the attraction region of a beacon <span class="MathJax_Preview"><script type="math/tex">
b
</script>
</span>. There are four algorithms in total. We will describe in detail only the first one, which is the one that we implented. In the complexity analyses, <span class="MathJax_Preview"><script type="math/tex">
n
</script>
</span> refers to the number of vertices of a polygon.
</div>
<h3 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-3.5.1">3.5.1</a> Algorithm 1
</h3>
<div class="Unindented">
This algorithm exploits the idea that we mentioned in Subsection REF. It employs a rotational sweep technique. First it sorts the vertices of a polygon radially around a beacon, then it examines the sorted list to find split vertices, maintining a status of the edges intersecting the sweep line in order of increasing distance from the beacon. Once a split vertex is found, it determines the corresponding ray vertex. In the end it will yeld the partition induced by the beacon. For a polygon with holes, we have to be careful excluding edges contained in a region, as we mentioned in Subsection REF. We now give the pseudocode of the algorithm (taken from <span class="bibcites">[<a class="bibliocite" name="cite-2" href="#biblio-2"><span class="bib-index">2</span></a>]</span>).
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--1"></a><div class="float">
<a class="Label" name="Algorithm-1"> </a><div class="algorithm">
<div class="listing">
<pre class="listing"><span class="number-left">1</span>procedure AttractionRegion(P, b)
<span class="number-left">2</span>	Sort the vertices by angle about b, and keep in an ordered event list L=(p1, p2, ..., pn)
<span class="number-left">3</span>	Find the order of intersection of edges from p1 along the ray bp1 and store as status S
<span class="number-left">4</span>	for the next vertex pi in L do
<span class="number-left">5</span>		Update S as necessary
<span class="number-left">6</span>		if pi is a split vertex with respect to b then
<span class="number-left">7</span>			Find qi, the ray-vertex of pi with respect to b
<span class="number-left">8</span>			Add qi to the arrangement of P
<span class="number-left">9</span>			Add edge (pi, qi) to the arrangement of P
<span class="number-left">10</span>		end if
<span class="number-left">11</span>	end for
<span class="number-left">12</span>	return the arrangement of P
<span class="number-left">13</span>end procedure
</pre>
</div>
<div class="caption">
Algorithm 1 <span class="MathJax_Preview"><script type="math/tex">
O(n\log n)
</script>
</span> running-time algorithm in simple polygons
</div>

</div>

</div>
<br/>
Complexity analysis
</div>
<div class="Unindented">
The algorithm requires a comparison-based sorting algorithm in order to obtain the ordered list of points. Since a comparisons can be done in constant time using turns, the sorting part takes <span class="MathJax_Preview"><script type="math/tex">
O(n\log n)
</script>
</span> as usual. Maintining a sweep line status also costs <span class="MathJax_Preview"><script type="math/tex">
O(n\log n)
</script>
</span>. Determining if a vertex is a split vertex takes constant time (we saw how to do this in Section REF). Finding the ray vertex also takes constant time, because we can exploit the sweep line status to find the edge on which it lies.<br/>
In polygons with holes, the time spent walking on regions’ boundaries is linear, so it is dominated, for instance, by the sorting algorithm.<br/>
The space complexity is <span class="MathJax_Preview"><script type="math/tex">
O(n)
</script>
</span>, because we can only find <span class="MathJax_Preview"><script type="math/tex">
O(n)
</script>
</span> split edges and, consequently, <span class="MathJax_Preview"><script type="math/tex">
O(n)
</script>
</span> components of divided edges.
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--2"></a>Implementation
</div>
<div class="Unindented">
In our implementation, we used a modified version of the quicksort algorithm in order to obtain the ordered event list, and we used a red-black binary search tree to maintain the sweep line status. An input polygon is stored and updated during the algorithm by using a doubly connected edge list. Adding a split edge and splitting the edge on which its ray vertex lies is achieved by a split-edge operation using the ray vertex, followed by a split-face that adds the split edge. 
</div>
<h3 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-3.5.2">3.5.2</a> Algorithm 2
</h3>
<div class="Unindented">
The second algorithm is similar to the first one, but in order to compute split edges it uses the geodesic triangulation data structure described in REF, which we don’t treat here beacuse it is not directly related to the topic. Basically this data structure allows performing ray shooting queries efficiently, after some initial preprocessing, thus avoiding sorting and maintaining a sweepline status, in order to find ray vertices.
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--3"></a>Complexity analysis
</div>
<div class="Unindented">
Preprocessing the polygon for the geodesic triangulation takes <span class="MathJax_Preview"><script type="math/tex">
O(n\log n)
</script>
</span>, although it might be completed in linear time by using the fastest triangulation algorightm known. A ray shooting query takes <span class="MathJax_Preview"><script type="math/tex">
O(\log n)
</script>
</span> for a split vertex and since we might have <span class="MathJax_Preview"><script type="math/tex">
\Theta\left(n\right)
</script>
</span> of them, we get a running time of <span class="MathJax_Preview"><script type="math/tex">
O(n\log n)
</script>
</span>.<br/>
In polygons with holes, the preprocessing time becomes <span class="MathJax_Preview"><script type="math/tex">
O\left(n\sqrt{h}+h^{\frac{3}{2}}\log h+n\log n\right)
</script>
</span>, while the query time is <span class="MathJax_Preview"><script type="math/tex">
O\left(\sqrt{h}\log n\right)
</script>
</span> (REF). Thus, getting the raw arrangement takes <span class="MathJax_Preview"><script type="math/tex">
O\left(\sqrt{h}n\log n\right)
</script>
</span>, and it dominates the postprocessing time to eliminate false positives, which is linear as we explained before.<br/>
Space complexity is again <span class="MathJax_Preview"><script type="math/tex">
O(n)
</script>
</span>.
</div>
<h3 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-3.5.3">3.5.3</a> Algorithm 3
</h3>
<div class="Unindented">
The third algorithm is more involved. It starts by computing a triangulation of the input polygon, form which it obtains its dual graph, later transformed in a directed tree, which it uses to select only the edges on the boundary of the attraction region, that are obtained by discarding the split edges that are &ldquo;outside&rdquo; other split edges (the path from the beacon to them crosses other split edges). For each triangle we record the split edges that propagate through it. A split edge that is found to be on the boundary of the attraction region is propagated iteratively through the triangles containing it, which will eventually lead to finding the ray vertex. The attraction region is simply the region containing the beacon.<br/>
In polygons with holes we do the same as for the previous algorithms, but only for the attraction region. We don’t need to compute a triangulation that considers the holes of the polygon.
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--4"></a>Complexity Analysis
</div>
<div class="Unindented">
The initial triangulation can be computed in <span class="MathJax_Preview"><script type="math/tex">
O(n)
</script>
</span> time, due to the algorithm in REF. Its dual, from which we obtain the directed tree and a list of interesting triangles can be obtained in linear time by performing a search from the triangle containing the beacon. Each triangle is considered once, and for each triangle we propagate at most two split edges (as the attraction reagon in a simple polygon is simple and all edges outside it are suddenly discarded), so we have a final running time equal to <span class="MathJax_Preview"><script type="math/tex">
O(n)
</script>
</span>.<br/>
For polygons with holes, the difference is that we would need to propagate <span class="MathJax_Preview"><script type="math/tex">
O(h)
</script>
</span> edges for each triangle, because of the holes, which might contribute with two split edges each, possibly propagated through many triangles. Thus the complexity becomes <span class="MathJax_Preview"><script type="math/tex">
O(hn)
</script>
</span>.<br/>
The triangulation , its dual, and the remaining data structures are all linear, so we get a space complexity of <span class="MathJax_Preview"><script type="math/tex">
O\left(n\right)
</script>
</span>.
</div>
<h3 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-3.5.4">3.5.4</a> Algorithm 4
</h3>
<div class="Unindented">
The last algorithm employs a radial trapezoidization. First it finds the visibility polygon of a beacon from the triangulation of the polygons, then it considers the remaining regions, for which it computes horizontal trapzoidizations in a projective space that brings the beacon to infinity. Reversing the projection yelds the radial trapezioidization of these regions. For each split vertex, use the trapezoidizations to find the ray vertex.<br/>
In polygons with holes the complexity is dominated by the triangulation, that here considers also the holes and it’s computed in <span class="MathJax_Preview"><script type="math/tex">
O\left(n+h\log^{1+\epsilon}h\right)
</script>
</span>.<br/>
Space complexity is linear as usual.
</div>
<h1 class="Section">
<a class="toc" name="toc-Section-4">4</a> The Inverse Attraction Region<a class="Label" name="sec:The-Inverse-Attraction"> </a>
</h1>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-4.1">4.1</a> Definition
</h2>
<div class="Definition">
Given a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> and a point <span class="MathJax_Preview"><script type="math/tex">
p\epsilon P
</script>
</span>, the inverse attraction region <span class="MathJax_Preview"><script type="math/tex">
IA\left(p\right)
</script>
</span> is the set of points in <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> to which <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> is attracted. 
</div>
<div class="Unindented">
a
</div>
<div class="Definition">
Given a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> and a subset <span class="MathJax_Preview"><script type="math/tex">
R
</script>
</span> of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, the inverse attraction region of <span class="MathJax_Preview"><script type="math/tex">
R
</script>
</span>, <span class="MathJax_Preview"><script type="math/tex">
IA\left(R\right)
</script>
</span>, is the set of points in <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> that attract at least one point in <span class="MathJax_Preview"><script type="math/tex">
R
</script>
</span>.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-4.2">4.2</a> Algorithm for the Inverse Attraction Region of a Point
</h2>
<div class="Unindented">
In order to obtain the inverse attraction region of a point, we can consider a line arrangement induced by a polygon <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, which we call <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{p}}
</script>
</span>, constructed in the following way: take the lines defined by the edges of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span> and, for each reflex vertex, those intersecting it that are perpendicular to its incident edges.<br/>
This arrangement has some interesting properties that give ideas for an algorithm.
</div>
<div class="Lemma">
Given two points <span class="MathJax_Preview"><script type="math/tex">
b_{1}
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
b_{2}
</script>
</span> contained in a face <span class="MathJax_Preview"><script type="math/tex">
F
</script>
</span> of <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{p}}
</script>
</span>, and given a vertex <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, if <span class="MathJax_Preview"><script type="math/tex">
p_{i}
</script>
</span> is a split vertex for <span class="MathJax_Preview"><script type="math/tex">
b_{1}
</script>
</span> when we consider it as a beacon, then it is also a split vertex for <span class="MathJax_Preview"><script type="math/tex">
b_{2}
</script>
</span> .
</div>
<div class="Unindented">
This interesting fact can be used to prove a even stronger result:
</div>
<div class="Theorem">
Given two points <span class="MathJax_Preview"><script type="math/tex">
b_{1}
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
b_{2}
</script>
</span> contained in a face <span class="MathJax_Preview"><script type="math/tex">
F
</script>
</span> of <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{p}}
</script>
</span>, and given a point <span class="MathJax_Preview"><script type="math/tex">
p
</script>
</span> of <span class="MathJax_Preview"><script type="math/tex">
P
</script>
</span>, if <span class="MathJax_Preview"><script type="math/tex">
p\epsilon A\left(b_{1}\right)
</script>
</span>, then it is also a split vertex for <span class="MathJax_Preview"><script type="math/tex">
p\epsilon A\left(b_{2}\right)
</script>
</span> .
</div>
<div class="Unindented">
This is a great simplification, because it’s telling us that we can just test a single point in a face of the considered arrangement. We now give the presudocode of the algorithm (taken from <span class="bibcites">[<a class="bibliocite" name="cite-2" href="#biblio-2"><span class="bib-index">2</span></a>]</span>).
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--5"></a><div class="float">
<a class="Label" name="Algorithm-2"> </a><div class="algorithm">
<div class="listing">
<pre class="listing"><span class="number-left">1</span>procedure InverseAttractionRegion(P, p)
<span class="number-left">2</span>	Initialize Ap = ∅
<span class="number-left">3</span>	for each edge e in P do
<span class="number-left">4</span>		Add line e to Ap
<span class="number-left">5</span>	end for
<span class="number-left">6</span>	for each reflex vertex r in P do
<span class="number-left">7</span>		Add line rp to Ap
<span class="number-left">8</span>		Add the lines r1 and r2 through r and perpendicular to the edges incident on r to Ap
<span class="number-left">9</span>	end for
<span class="number-left">10</span>	Initialize IA(p) = ∅
<span class="number-left">11</span>	for each face F of Ap do
<span class="number-left">12</span>		Choose an arbitrary point bF of F and compute A(bF)
<span class="number-left">13</span>		if p ∈ A(bF ) then
<span class="number-left">14</span>			Add F to IA(p)
<span class="number-left">15</span>		end if
<span class="number-left">16</span>	end for
<span class="number-left">17</span>	return IA(p), the inverse attraction region of p
<span class="number-left">18</span>end procedure
</pre>
</div>
<div class="caption">
Algorithm 2 <span class="MathJax_Preview"><script type="math/tex">
O(n^{2})
</script>
</span>running-time algorithm for <span class="MathJax_Preview"><script type="math/tex">
IA(p)
</script>
</span>
</div>

</div>

</div>
Complexity Analysis
</div>
<div class="Unindented">
This algorithm uses an attraction region algorithm (<span class="MathJax_Preview"><script type="math/tex">
O\left(n\right)
</script>
</span>/<span class="MathJax_Preview"><script type="math/tex">
O\left(n+h\log^{1+\epsilon}h\right)
</script>
</span>) and it tests, for each attraction region computed, if the given point is in it (<span class="MathJax_Preview"><script type="math/tex">
O\left(n\right)
</script>
</span>). There are <span class="MathJax_Preview"><script type="math/tex">
O\left(n^{2}\right)
</script>
</span> faces in the arrangement, but walking through them in a breadth-first fashion using the dual graph allows updating the attraction regions, quickly, making the overall complexity <span class="MathJax_Preview"><script type="math/tex">
O\left(n^{2}\right)
</script>
</span>.<br/>
The space complexity is <span class="MathJax_Preview"><script type="math/tex">
O\left(n^{2}\right)
</script>
</span>.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-4.3">4.3</a> Algorithm for the Inverse Attraction Region of a Region
</h2>
<div class="Unindented">
To compute the attraction region of a region, it is convenient to consider a modified version of the line arrangement considered above. We call the new arrangement <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{R}}
</script>
</span> and we obtain it by considering the lines from each reflex vertex of the input regions through each reflex vertex of the input polygon. This arrangement has a property that is similar to that of <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{p}}
</script>
</span> with respect to attracting points in a region.
</div>
<div class="Theorem">
Given two points <span class="MathJax_Preview"><script type="math/tex">
b_{1}
</script>
</span> and <span class="MathJax_Preview"><script type="math/tex">
b_{2}
</script>
</span> contained in a face <span class="MathJax_Preview"><script type="math/tex">
F
</script>
</span> of <span class="MathJax_Preview"><script type="math/tex">
\mathit{A_{R}}
</script>
</span>, if <span class="MathJax_Preview"><script type="math/tex">
R\cap A\left(b_{1}\right)\neq\varnothing
</script>
</span>, then <span class="MathJax_Preview"><script type="math/tex">
R\cap A\left(b_{2}\right)\neq\varnothing
</script>
</span> .
</div>
<div class="Unindented">
Thanks to this fact we can easily determine te attraction region of <span class="MathJax_Preview"><script type="math/tex">
R
</script>
</span>, by using a point for each face of the arrangement.
</div>
<h1 class="Section">
<a class="toc" name="toc-Section-5">5</a> Algorithms for Beacon-Based Routing<a class="Label" name="sec:Algorithms-for-Beacon-Based"> </a>
</h1>
<div class="Unindented">
Now that we have seen how to compute these two regions, we would like to use them in order to perform beacon-based routing. We would also like to find the minimum routing paths each time. In this section we consider first the case where we are given a set of candidate beacons, then the case where we have no beacon except the destination, which we solve with a nearly optimal approximation algorithm.
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-5.1">5.1</a> Algorithm for Routing with Candidate Beacons
</h2>
<div class="Unindented">
This algorithm’s main task consists in building a directed graph, that has the candidate beacons, the starting point and the destination as nodes, and edges of the type <span class="MathJax_Preview"><script type="math/tex">
\overrightarrow{\left(u,v\right)}
</script>
</span> if <span class="MathJax_Preview"><script type="math/tex">
u\in A\left(v\right)
</script>
</span>. Once the graph is computed, the routing path is simply a shortest path between the starting point and the destination. We now give the pseudocode of the algorithm (taken from <span class="bibcites">[<a class="bibliocite" name="cite-2" href="#biblio-2"><span class="bib-index">2</span></a>]</span>).
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--6"></a><div class="float">
<a class="Label" name="Algorithm-3"> </a><div class="algorithm">
<div class="listing">
<pre class="listing"><span class="number-left">1</span>procedure Minimum Beacon Path with Candidates(P,M, s, t)
<span class="number-left">2</span>	Compute a triangulation T of P 
<span class="number-left">3</span>	C = M ∪ s ∪ t 
<span class="number-left">4</span>	Initialize directed graph G = (C, ∅) 
<span class="number-left">5</span>	for each c ∈ C do 
<span class="number-left">6</span>		Compute A(c) 
<span class="number-left">7</span>		for each triangle t ∈ T do 
<span class="number-left">8</span>			Record the subset of t that is attractable to c 
<span class="number-left">9</span>			for each d ∈ M ∩ t do 
<span class="number-left">10</span>				if d ∈ A(c) then 
<span class="number-left">11</span>					Add directed edge dc to G 
<span class="number-left">12</span>				end if 
<span class="number-left">13</span>			end for 
<span class="number-left">14</span>		end for 
<span class="number-left">15</span>	end for 
<span class="number-left">16</span>	Find a shortest path p from s to t in G 
<span class="number-left">17</span>	return the sequence of beacons in p 
<span class="number-left">18</span>end procedure
</pre>
</div>
<div class="caption">
Algorithm 3 <span class="MathJax_Preview"><script type="math/tex">
O(m(n+m))
</script>
</span>running-time algorithm in simple polygons
</div>

</div>

</div>

</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--7"></a>Complexity Analysis
</div>
<div class="Paragraph-">
<a class="toc" name="toc-Paragraph--8"></a>Implementation
</div>
<h2 class="Subsection">
<a class="toc" name="toc-Subsection-5.2">5.2</a> Approximation Algorithm
</h2>
<div class="Unindented">
This algorithm stars from a triangulation of a given polygon, then it builds a 
</div>
<div class="Indented">
<h1 class="biblio">
References
</h1>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-1"><span class="bib-index">1</span></a>] </span> <span class="bib-authors">Michael Biro, Justin Iwerks, Irina Kostitsyna, Joseph S. B. Mitchell</span>. <span class="bib-title">Algorithms and Data Structures: 13th International Symposium, WADS 2013, London, ON, Canada, August 12-14, 2013. Proceedings</span>. <span class="bib-publisher">Springer Berlin Heidelberg</span>, <span class="bib-year">2013</span>. URL <a href="http://dx.doi.org/10.1007/978-3-642-40104-6_14"><span class="bib-url">http://dx.doi.org/10.1007/978-3-642-40104-6_14</span></a>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-2"><span class="bib-index">2</span></a>] </span> <span class="bib-authors">Michael Biro</span>. <span class="bib-title">Beacon-based routing and guarding</span>. <span class="bib-year">2013</span>.
</p>

</div>

</div>
</body>
</html>
